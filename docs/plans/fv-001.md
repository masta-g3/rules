# fv-001: Feature Viewer TUI

**A terminal-native feature tracking dashboard**

> "Above all else show the data." — Edward Tufte

---

## Overview

A single-file Python script (`fv`) that renders `features.json` as an information-dense terminal dashboard. Invoked from any repo containing a `features.json`, it provides instant insight into project progress, feature dependencies, and epic health.

**Design Philosophy:**
- **Tufte-inspired**: Maximize data-ink ratio. Every pixel earns its place.
- **Glanceable**: Status visible in <1 second. Deep-dive available on demand.
- **Zero dependencies**: Pure Python 3.10+ stdlib. No pip install, no venv.
- **Single file**: Copy anywhere, alias once, use everywhere.

---

## Data Schema Analysis

From `features.json` analysis:

```
Fields found:
├── id           (required) - e.g., "farm-001", "shrine-017"
├── status       (required) - done|pending|in_progress|abandoned|superseded|complete
├── epic         (optional) - groups features: farm, shrine, asset-gen, poi, ui, world
├── title        (optional) - short description
├── description  (optional) - longer explanation
├── steps        (optional) - array of implementation steps
├── depends_on   (optional) - array of feature IDs this blocks on
├── priority     (optional) - numeric or string (0=critical, "low"=defer)
├── created_at   (optional) - ISO date
├── spec_file    (optional) - path to detailed spec
├── discovered_from (optional) - parent feature that spawned this
├── notes        (optional) - freeform text
```

---

## Design Specification

### Visual Language

**Color Palette** (ANSI 256-color safe):

```
┌─────────────────────────────────────────────────────┐
│  Background     │  Terminal default (transparent)   │
│  Primary Text   │  Default foreground               │
│  Muted Text     │  ANSI 240 (gray)                  │
│  Done           │  ANSI 34 (green)                  │
│  In Progress    │  ANSI 33 (yellow)                 │
│  Pending        │  ANSI 245 (light gray)            │
│  Abandoned      │  ANSI 238 (dark gray, struck)     │
│  Epic Accent    │  ANSI 39 (cyan)                   │
│  Dependency     │  ANSI 213 (magenta)               │
│  Border         │  ANSI 237 (subtle gray)           │
└─────────────────────────────────────────────────────┘
```

**Typography:**
- Monospace (terminal native)
- Heavy use of Unicode box-drawing for structure
- Sparklines (▁▂▃▄▅▆▇█) for temporal activity
- Status indicators: ✓ done, ◉ in_progress, ○ pending, ✗ abandoned, ↷ superseded

**Layout Density:**
- No chrome, no padding-for-padding's-sake
- Horizontal rules only where they aid scanning
- Data-forward: numbers and statuses visible first

### Screen Layouts

#### View 1: Dashboard (default)

```
┌─ features.json ─────────────────────────────────────── harvest-bloom ─┐
│                                                                       │
│  PROGRESS ══════════════════════════════════════════════════════════  │
│                                                                       │
│  ████████████████████████████████████████████░░░░░░░  57/63  90.5%   │
│  ✓ 57 done   ◉ 1 active   ○ 2 pending   ✗ 1 abandoned   ↷ 1 super   │
│                                                                       │
│  EPICS ═════════════════════════════════════════════════════════════  │
│                                                                       │
│  shrine     ████████████████▒░  17/18  94%   ◉ 1 active              │
│  farm       ████████████████    11/11 100%                           │
│  asset-gen  ████████░           4/5   80%   ✗ 1 abandoned            │
│  poi        ████░░░░░░          1/3   33%   ◉ 1 active   ○ 1 pending │
│  world      ████████            2/2  100%                            │
│  ui         ████░░░░░           1/2   50%   ○ 1 pending              │
│  (none)     ████████████████████████  23/23 100%                     │
│                                                                       │
│  RECENT ════════════════════════════════════════════════════════════  │
│                                                                       │
│  Jan 22  ▆▆  poi-core, player-002                                    │
│  Jan 21  ████  shrine-020, shrine-021, shrine-022, world-003         │
│  Jan 20  ██████  shrine-010..018, test-001                           │
│  Jan 19  ████████  farm-012..017, shrine-001..009                    │
│  Jan 18  ██████████████  asset-gen-*, farm-000..011                  │
│                                                                       │
│  NEXT UP ═══════════════════════════════════════════════════════════  │
│                                                                       │
│  ◉ poi-minimap        Minimap UI Component              → unlocks: poi-testing │
│  ○ poi-testing        POI Testing Infrastructure        → unlocks: (none)      │
│  ○ ui-002             Quest Projects/Objectives UI      → unlocks: (none)      │
│                                                                       │
└─────────────────────────────────────────────────────────────── [e]pic [q]uit ─┘
```

#### View 2: Epic Detail

```
┌─ epic: shrine ──────────────────────────────────────────────────────────┐
│                                                                         │
│  ████████████████▒░  17/18 completed   94%                             │
│                                                                         │
│  FEATURES ══════════════════════════════════════════════════════════   │
│                                                                         │
│  ✓ shrine-001   Phaser Scene Transition System                         │
│  ✓ shrine-002   ShrineScene Skeleton                      ← shrine-001 │
│  ✓ shrine-003   Generate Exterior Temple Sprite                        │
│  ✓ shrine-004   Temple Placement in Island Generator      ← shrine-003 │
│  ✓ shrine-005   Door Collision & Entry Trigger            ← 002, 004   │
│  ✓ shrine-006   Generate Interior Tileset                              │
│  ✓ shrine-007   Interior Tilemap & Layout                 ← 002, 006   │
│  ✓ shrine-008   Player Movement in ShrineScene            ← shrine-007 │
│  ✓ shrine-009   Exit Mechanism                            ← shrine-008 │
│  ✓ shrine-010   Generate Decoration Assets                             │
│  ✓ shrine-011   Place Decorations (Fixed Layout)          ← 007, 010   │
│  ✓ shrine-012   Light Particle Effects                    ← shrine-011 │
│  ✓ shrine-013   Quest Board Sprite & Placement            ← shrine-007 │
│  ✓ shrine-014   Board Interaction Detection               ← shrine-013 │
│  ✓ shrine-015   Full-Screen Modal UI System               ← shrine-014 │
│  ✓ shrine-016   Quest Data Display                        ← shrine-015 │
│  ✓ shrine-017   Edge Case Handling                        ← 009, 016   │
│  ◉ shrine-024   Temple Exit Bug Fix                       ← shrine-021 │
│                                                                         │
│  DEPENDENCY CHAIN ══════════════════════════════════════════════════   │
│                                                                         │
│  001 → 002 → 005 ─┬→ 007 → 008 → 009 → 017                            │
│  003 → 004 ───────┘    │                 ↑                             │
│  006 ─────────────────┘                 │                             │
│  010 → 011 → 012                         │                             │
│  013 → 014 → 015 → 016 ─────────────────┘                             │
│                                                                         │
└────────────────────────────────────────────── [←] back [f]eature [q]uit ─┘
```

#### View 3: Feature Detail

```
┌─ shrine-024 ─────────────────────────────────────────────────────────────┐
│                                                                          │
│  Temple Exit Bug Fix                                        ◉ in_progress │
│                                                                          │
│  DESCRIPTION ════════════════════════════════════════════════════════   │
│                                                                          │
│  Fix temple exit not working. Player should be able to leave shrine     │
│  by walking to exit tiles at bottom center. Investigate and fix the     │
│  transition back to GameScene.                                          │
│                                                                          │
│  METADATA ═══════════════════════════════════════════════════════════   │
│                                                                          │
│  Epic        shrine                                                      │
│  Priority    0 (critical)                                               │
│  Created     2026-01-21                                                  │
│  Spec        docs/history/20260121_shrine-024_temple_exit_fix.md        │
│                                                                          │
│  DEPENDENCIES ═══════════════════════════════════════════════════════   │
│                                                                          │
│  Blocked by: shrine-021 ✓                                               │
│  Blocks:     (none)                                                     │
│                                                                          │
│  STEPS ══════════════════════════════════════════════════════════════   │
│                                                                          │
│  (no steps defined)                                                     │
│                                                                          │
└─────────────────────────────────────────────── [←] back [e]pic [q]uit ──┘
```

---

## Architecture

```
┌────────────────────────────────────────────────────────────────────────┐
│                           fv (single file)                             │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                │
│  │   Parser    │───▶│   Model     │───▶│   Views     │                │
│  └─────────────┘    └─────────────┘    └─────────────┘                │
│        │                  │                   │                        │
│        ▼                  ▼                   ▼                        │
│  - Load JSON        - Feature          - Dashboard                     │
│  - Validate         - Epic             - EpicDetail                    │
│  - Normalize        - Stats            - FeatureDetail                 │
│                     - Dependencies                                     │
│                                                                        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                │
│  │   Render    │◀───│   State     │───▶│   Input     │                │
│  └─────────────┘    └─────────────┘    └─────────────┘                │
│        │                  │                   │                        │
│        ▼                  ▼                   ▼                        │
│  - ANSI colors      - Current view     - Key bindings                  │
│  - Box drawing      - Selection        - Navigation                    │
│  - Layout           - Scroll offset    - Filtering                     │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

### Module Breakdown

```python
# ═══════════════════════════════════════════════════════════════════════
# SECTION 1: CONSTANTS & CONFIG
# ═══════════════════════════════════════════════════════════════════════

STATUS_SYMBOLS = {
    'done': '✓', 'complete': '✓',
    'in_progress': '◉',
    'pending': '○',
    'abandoned': '✗',
    'superseded': '↷',
}

STATUS_COLORS = {
    'done': 34, 'complete': 34,  # green
    'in_progress': 33,           # yellow
    'pending': 245,              # gray
    'abandoned': 238,            # dark gray
    'superseded': 238,           # dark gray
}

# ═══════════════════════════════════════════════════════════════════════
# SECTION 2: ANSI RENDERING
# ═══════════════════════════════════════════════════════════════════════

def ansi(text: str, color: int = None, bold: bool = False) -> str:
    """Wrap text in ANSI escape codes."""

def bar(filled: int, total: int, width: int = 40) -> str:
    """Render a progress bar using block characters."""

def sparkline(values: list[int], width: int = 10) -> str:
    """Render values as unicode sparkline."""

# ═══════════════════════════════════════════════════════════════════════
# SECTION 3: DATA MODEL
# ═══════════════════════════════════════════════════════════════════════

@dataclass
class Feature:
    id: str
    status: str
    title: str
    description: str
    epic: str | None
    depends_on: list[str]
    priority: int | None
    created_at: str | None
    spec_file: str | None
    steps: list[str]

@dataclass
class Epic:
    name: str
    features: list[Feature]
    done: int
    total: int

@dataclass
class Model:
    features: dict[str, Feature]
    epics: dict[str, Epic]
    activity: dict[str, list[str]]  # date -> feature ids

# ═══════════════════════════════════════════════════════════════════════
# SECTION 4: VIEWS
# ═══════════════════════════════════════════════════════════════════════

def view_dashboard(model: Model, width: int, height: int) -> list[str]:
    """Main dashboard view."""

def view_epic(model: Model, epic_name: str, width: int, height: int) -> list[str]:
    """Epic detail view with dependency chain."""

def view_feature(model: Model, feature_id: str, width: int, height: int) -> list[str]:
    """Feature detail view."""

# ═══════════════════════════════════════════════════════════════════════
# SECTION 5: INPUT & STATE
# ═══════════════════════════════════════════════════════════════════════

@dataclass
class State:
    view: str  # 'dashboard' | 'epic' | 'feature'
    selected_epic: str | None
    selected_feature: str | None
    scroll: int

def handle_input(key: str, state: State, model: Model) -> State:
    """Process keypress and return new state."""

# ═══════════════════════════════════════════════════════════════════════
# SECTION 6: MAIN LOOP
# ═══════════════════════════════════════════════════════════════════════

def main():
    """Entry point."""
```

---

## Implementation Phases

### Phase 1: Core Foundation
- [x] Create script skeleton with argument parsing
- [x] Implement JSON loader with validation
- [x] Build Feature and Model dataclasses
- [x] Implement basic ANSI helpers (color, bold)
- [x] Terminal size detection via `shutil.get_terminal_size()`

**Verification:** ✓ `./fv --help` shows usage, `./fv` loads and parses features.json

### Phase 2: Dashboard View (Static)
- [x] Implement progress bar with block characters
- [x] Implement status counting and display
- [x] Implement epic progress bars with percentages
- [x] Implement recent activity sparkline (group by created_at)
- [x] Implement "next up" section listing pending/in_progress
- [x] Box-drawing frame around entire view

**Verification:** ✓ Dashboard shows all sections with correct data (58/63 done, 92.1%)

### Phase 3: Interactive Navigation
- [x] Implement raw terminal input (tty settings, single char read)
- [x] Add State management with view switching
- [x] Implement epic list selection (j/k or arrows)
- [x] Add `e` key to enter epic detail
- [x] Add `f` key to enter feature list/detail
- [x] Add `q` to quit, `←`/backspace to go back

**Verification:** ✓ Navigation works in non-interactive mode, input handlers implemented

### Phase 4: Detail Views
- [x] Implement epic detail view with feature list
- [x] Implement dependency indicators (← deps shown inline)
- [x] Implement feature detail view with all metadata

**Verification:** ✓ All three views implemented with correct rendering

### Phase 5: Polish & Edge Cases
- [x] Handle missing fields gracefully
- [x] Handle empty features.json
- [x] Handle malformed JSON with helpful error
- [x] Truncate long text to terminal width
- [ ] Add scroll for long lists (when terminal height exceeded) — deferred
- [ ] Handle terminal resize (SIGWINCH) — deferred

**Verification:** ✓ Empty file shows "All features complete!", minimal file works, nonexistent file shows error

### Phase 6: Installation & Alias
- [x] Add shebang and make executable
- [x] Document installation in script header
- [x] Test from different directories
- [x] Verify works with `alias fv='python3 /path/to/fv'`

**Verification:** ✓ Script at ~/.local/bin/fv, executable, works from any directory

---

## Code Implementation

### File: `~/.local/bin/fv`

```python
#!/usr/bin/env python3
"""
fv - Feature Viewer TUI

A terminal dashboard for features.json tracking files.
Zero dependencies, pure Python 3.10+ stdlib.

Usage:
    fv                    # View features.json in current directory
    fv path/to/file.json  # View specific file
    fv --help             # Show help

Navigation:
    j/k or ↑/↓  Move selection
    Enter/e     View epic details
    f           View feature details (from epic view)
    b/Esc       Go back
    q           Quit

Install:
    chmod +x fv
    mv fv ~/.local/bin/
    # Or: alias fv='python3 /path/to/fv'
"""

from __future__ import annotations

import json
import os
import re
import sys
import tty
import termios
from dataclasses import dataclass, field
from shutil import get_terminal_size
from typing import Any
from datetime import datetime

# Regex to strip ANSI escape codes for visible length calculation
ANSI_ESCAPE = re.compile(r'\033\[[0-9;]*m')

# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

STATUS_DONE = {'done', 'complete'}
STATUS_ACTIVE = {'in_progress'}
STATUS_PENDING = {'pending'}
STATUS_INACTIVE = {'abandoned', 'superseded'}

STATUS_SYMBOL = {
    'done': '✓', 'complete': '✓',
    'in_progress': '◉',
    'pending': '○',
    'abandoned': '✗',
    'superseded': '↷',
}

STATUS_COLOR = {
    'done': 34, 'complete': 34,
    'in_progress': 33,
    'pending': 245,
    'abandoned': 238,
    'superseded': 238,
}

COLOR_MUTED = 240
COLOR_EPIC = 39
COLOR_DEP = 213
COLOR_BORDER = 237

BOX = {
    'tl': '┌', 'tr': '┐', 'bl': '└', 'br': '┘',
    'h': '─', 'v': '│', 'title': '═',
}

BLOCKS = ' ▏▎▍▌▋▊▉█'
SPARK = '▁▂▃▄▅▆▇█'


# ═══════════════════════════════════════════════════════════════════════════════
# ANSI RENDERING
# ═══════════════════════════════════════════════════════════════════════════════

def ansi(text: str, color: int | None = None, bold: bool = False, dim: bool = False) -> str:
    """Wrap text in ANSI escape codes."""
    if not (color or bold or dim):
        return text
    codes = []
    if bold:
        codes.append('1')
    if dim:
        codes.append('2')
    if color:
        codes.append(f'38;5;{color}')
    return f"\033[{';'.join(codes)}m{text}\033[0m"


def visible_len(text: str) -> int:
    """Get visible length of text, stripping ANSI codes."""
    return len(ANSI_ESCAPE.sub('', text))


def progress_bar(done: int, total: int, width: int = 40) -> str:
    """Render progress bar with fine-grained blocks."""
    if total == 0:
        return ansi('░' * width, COLOR_MUTED)

    ratio = done / total
    filled_full = int(ratio * width)
    remainder = (ratio * width) - filled_full
    partial_idx = int(remainder * 8)

    filled_chars = filled_full
    bar = '█' * filled_full
    if filled_full < width and partial_idx > 0:
        bar += BLOCKS[partial_idx]
        filled_chars += 1
    bar += '░' * (width - filled_chars)

    # Color: green for filled portion, gray for remaining
    done_part = ansi(bar[:filled_chars], 34)
    remaining = ansi(bar[filled_chars:], COLOR_MUTED)
    return done_part + remaining


def sparkline(values: list[int], width: int | None = None) -> str:
    """Render values as unicode sparkline."""
    if not values:
        return ''
    if width and len(values) > width:
        values = values[-width:]

    max_val = max(values) if values else 1
    if max_val == 0:
        return SPARK[0] * len(values)

    return ''.join(SPARK[min(7, int(v / max_val * 7))] for v in values)


def truncate(text: str, width: int) -> str:
    """Truncate text to width, adding ellipsis if needed."""
    if len(text) <= width:
        return text
    return text[:width - 1] + '…'


# ═══════════════════════════════════════════════════════════════════════════════
# DATA MODEL
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class Feature:
    id: str
    status: str
    title: str = ''
    description: str = ''
    epic: str | None = None
    depends_on: list[str] = field(default_factory=list)
    priority: int | None = None
    created_at: str | None = None
    spec_file: str | None = None
    steps: list[str] = field(default_factory=list)
    discovered_from: str | None = None
    notes: str | None = None

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Feature:
        # Handle title vs name inconsistency
        title = d.get('title') or d.get('name') or d.get('description', '')[:60] or d['id']
        # Normalize priority
        priority = d.get('priority')
        if isinstance(priority, str):
            priority = {'low': 3, 'medium': 2, 'high': 1, 'critical': 0}.get(priority.lower())

        return cls(
            id=d['id'],
            status=d.get('status', 'pending'),
            title=title,
            description=d.get('description', ''),
            epic=d.get('epic'),
            depends_on=d.get('depends_on', []),
            priority=priority,
            created_at=d.get('created_at'),
            spec_file=d.get('spec_file'),
            steps=d.get('steps', []),
            discovered_from=d.get('discovered_from'),
            notes=d.get('notes'),
        )

    @property
    def is_done(self) -> bool:
        return self.status in STATUS_DONE

    @property
    def is_active(self) -> bool:
        return self.status in STATUS_ACTIVE

    @property
    def is_pending(self) -> bool:
        return self.status in STATUS_PENDING


@dataclass
class Epic:
    name: str
    features: list[Feature] = field(default_factory=list)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features if f.is_pending)

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def percent(self) -> float:
        return (self.done / self.total * 100) if self.total else 0


@dataclass
class Model:
    features: dict[str, Feature]
    epics: dict[str, Epic]
    activity: dict[str, list[str]]  # date string -> feature ids

    @classmethod
    def load(cls, path: str) -> Model:
        with open(path) as f:
            data = json.load(f)

        features = {}
        epics: dict[str, Epic] = {}
        activity: dict[str, list[str]] = {}

        for item in data:
            feat = Feature.from_dict(item)
            features[feat.id] = feat

            # Group by epic
            epic_name = feat.epic or '(no epic)'
            if epic_name not in epics:
                epics[epic_name] = Epic(name=epic_name)
            epics[epic_name].features.append(feat)

            # Group by date
            if feat.created_at:
                if feat.created_at not in activity:
                    activity[feat.created_at] = []
                activity[feat.created_at].append(feat.id)

        # Sort epics by completion desc, then name
        epics = dict(sorted(epics.items(), key=lambda x: (-x[1].percent, x[0])))

        return cls(features=features, epics=epics, activity=activity)

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features.values() if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features.values() if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features.values() if f.is_pending)

    def upcoming(self) -> list[Feature]:
        """Get active and pending features, sorted by priority then date."""
        upcoming = [f for f in self.features.values() if f.is_active or f.is_pending]
        # Sort: active first, then by priority (lower=higher priority), then by date
        return sorted(upcoming, key=lambda f: (
            0 if f.is_active else 1,
            f.priority if f.priority is not None else 999,
            f.created_at or '9999',
        ))

    def unlocks(self, feature_id: str) -> list[str]:
        """Find features that depend on this one."""
        return [f.id for f in self.features.values() if feature_id in f.depends_on]


# ═══════════════════════════════════════════════════════════════════════════════
# VIEWS
# ═══════════════════════════════════════════════════════════════════════════════

def frame(lines: list[str], width: int, title: str = '', footer: str = '') -> list[str]:
    """Wrap lines in a box frame."""
    inner_width = width - 2
    result = []

    # Top border with title
    if title:
        title_str = f' {title} '
        pad_left = 2
        pad_right = inner_width - len(title_str) - pad_left
        top = BOX['tl'] + BOX['h'] * pad_left + title_str + BOX['h'] * pad_right + BOX['tr']
    else:
        top = BOX['tl'] + BOX['h'] * inner_width + BOX['tr']
    result.append(ansi(top, COLOR_BORDER))

    # Content lines
    for line in lines:
        vlen = visible_len(line)
        padding = inner_width - min(vlen, inner_width)
        result.append(ansi(BOX['v'], COLOR_BORDER) + line + ' ' * max(0, padding) + ansi(BOX['v'], COLOR_BORDER))

    # Bottom border with footer
    if footer:
        footer_str = f' {footer} '
        pad_right = 2
        pad_left = inner_width - len(footer_str) - pad_right
        bottom = BOX['bl'] + BOX['h'] * pad_left + footer_str + BOX['h'] * pad_right + BOX['br']
    else:
        bottom = BOX['bl'] + BOX['h'] * inner_width + BOX['br']
    result.append(ansi(bottom, COLOR_BORDER))

    return result


def section_header(title: str, width: int) -> str:
    """Create a section header with title and line."""
    return f"  {ansi(title, bold=True)} {ansi(BOX['title'] * (width - len(title) - 4), COLOR_MUTED)}"


def view_dashboard(model: Model, width: int, height: int) -> list[str]:
    """Render main dashboard."""
    lines = []
    inner = width - 4

    # Overall progress
    lines.append('')
    lines.append(section_header('PROGRESS', inner))
    lines.append('')

    pct = (model.done / model.total * 100) if model.total else 0
    bar_width = min(50, inner - 20)
    lines.append(f"  {progress_bar(model.done, model.total, bar_width)}  {model.done}/{model.total}  {pct:.1f}%")

    # Status summary
    status_parts = []
    if model.done:
        status_parts.append(ansi(f"✓ {model.done} done", STATUS_COLOR['done']))
    if model.active:
        status_parts.append(ansi(f"◉ {model.active} active", STATUS_COLOR['in_progress']))
    if model.pending:
        status_parts.append(ansi(f"○ {model.pending} pending", STATUS_COLOR['pending']))
    abandoned = sum(1 for f in model.features.values() if f.status == 'abandoned')
    if abandoned:
        status_parts.append(ansi(f"✗ {abandoned} abandoned", STATUS_COLOR['abandoned']))
    lines.append('  ' + '   '.join(status_parts))

    # Epics
    lines.append('')
    lines.append(section_header('EPICS', inner))
    lines.append('')

    for epic_name, epic in model.epics.items():
        bar_w = 16
        bar = progress_bar(epic.done, epic.total, bar_w)
        pct = f"{epic.percent:3.0f}%" if epic.total else "  -"
        name = truncate(epic_name, 12).ljust(12)
        count = f"{epic.done}/{epic.total}".rjust(5)

        status_hint = ''
        if epic.active:
            status_hint += ansi(f"  ◉ {epic.active} active", STATUS_COLOR['in_progress'])
        if epic.pending:
            status_hint += ansi(f"  ○ {epic.pending} pending", STATUS_COLOR['pending'])

        lines.append(f"  {ansi(name, COLOR_EPIC)}  {bar}  {count} {pct}{status_hint}")

    # Recent activity
    lines.append('')
    lines.append(section_header('RECENT', inner))
    lines.append('')

    sorted_dates = sorted(model.activity.keys(), reverse=True)[:5]
    max_count = max((len(model.activity[d]) for d in sorted_dates), default=1)

    for date in sorted_dates:
        feature_ids = model.activity[date]
        count = len(feature_ids)
        spark = '█' * min(14, int(count / max_count * 14))
        spark = ansi(spark.ljust(14), 34)

        # Format date nicely
        try:
            dt = datetime.fromisoformat(date)
            date_str = dt.strftime('%b %d')
        except:
            date_str = date[-5:]

        # Show first few feature IDs
        ids_preview = ', '.join(feature_ids[:3])
        if len(feature_ids) > 3:
            ids_preview += f'... (+{len(feature_ids) - 3})'

        lines.append(f"  {date_str}  {spark}  {ansi(ids_preview, COLOR_MUTED)}")

    # Next up
    lines.append('')
    lines.append(section_header('NEXT UP', inner))
    lines.append('')

    upcoming = model.upcoming()[:3]
    for feat in upcoming:
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        name = truncate(feat.id, 18).ljust(18)
        title = truncate(feat.title, 35).ljust(35)

        unlocks = model.unlocks(feat.id)
        unlock_str = f"→ unlocks: {', '.join(unlocks[:2])}" if unlocks else ''

        lines.append(f"  {ansi(sym, color)} {ansi(name, color)}  {title}  {ansi(unlock_str, COLOR_DEP)}")

    lines.append('')
    return lines


def view_epic(model: Model, epic_name: str, width: int, height: int) -> list[str]:
    """Render epic detail view."""
    epic = model.epics.get(epic_name)
    if not epic:
        return [f"Epic '{epic_name}' not found"]

    lines = []
    inner = width - 4

    # Header stats
    lines.append('')
    bar_w = min(50, inner - 30)
    lines.append(f"  {progress_bar(epic.done, epic.total, bar_w)}  {epic.done}/{epic.total} completed  {epic.percent:.0f}%")

    # Features list
    lines.append('')
    lines.append(section_header('FEATURES', inner))
    lines.append('')

    for feat in sorted(epic.features, key=lambda f: f.id):
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        fid = truncate(feat.id, 14).ljust(14)
        title = truncate(feat.title, 45)

        deps = ''
        if feat.depends_on:
            dep_list = ', '.join(d.split('-')[-1] for d in feat.depends_on[:2])
            deps = ansi(f"← {dep_list}", COLOR_DEP)

        lines.append(f"  {ansi(sym, color)} {fid}  {title}  {deps}")

    lines.append('')
    return lines


def view_feature(model: Model, feature_id: str, width: int, height: int) -> list[str]:
    """Render feature detail view."""
    feat = model.features.get(feature_id)
    if not feat:
        return [f"Feature '{feature_id}' not found"]

    lines = []
    inner = width - 4

    # Title and status
    lines.append('')
    sym = STATUS_SYMBOL.get(feat.status, '?')
    color = STATUS_COLOR.get(feat.status, 0)
    status_str = ansi(f"{sym} {feat.status}", color)
    lines.append(f"  {ansi(feat.title, bold=True)}")
    lines.append(f"  {status_str}")

    # Description
    if feat.description:
        lines.append('')
        lines.append(section_header('DESCRIPTION', inner))
        lines.append('')
        # Word wrap description
        words = feat.description.split()
        line = '  '
        for word in words:
            if len(line) + len(word) + 1 > inner:
                lines.append(line)
                line = '  '
            line += word + ' '
        if line.strip():
            lines.append(line)

    # Metadata
    lines.append('')
    lines.append(section_header('METADATA', inner))
    lines.append('')

    if feat.epic:
        lines.append(f"  {'Epic':<12}  {ansi(feat.epic, COLOR_EPIC)}")
    if feat.priority is not None:
        prio_label = {0: 'critical', 1: 'high', 2: 'medium', 3: 'low'}.get(feat.priority, str(feat.priority))
        lines.append(f"  {'Priority':<12}  {feat.priority} ({prio_label})")
    if feat.created_at:
        lines.append(f"  {'Created':<12}  {feat.created_at}")
    if feat.spec_file:
        lines.append(f"  {'Spec':<12}  {ansi(feat.spec_file, COLOR_MUTED)}")

    # Dependencies
    lines.append('')
    lines.append(section_header('DEPENDENCIES', inner))
    lines.append('')

    if feat.depends_on:
        deps_status = []
        for dep_id in feat.depends_on:
            dep = model.features.get(dep_id)
            if dep:
                s = STATUS_SYMBOL.get(dep.status, '?')
                deps_status.append(f"{dep_id} {ansi(s, STATUS_COLOR.get(dep.status, 0))}")
            else:
                deps_status.append(f"{dep_id} ?")
        lines.append(f"  {'Blocked by:':<12}  {', '.join(deps_status)}")
    else:
        lines.append(f"  {'Blocked by:':<12}  (none)")

    unlocks = model.unlocks(feature_id)
    lines.append(f"  {'Unlocks:':<12}  {', '.join(unlocks) if unlocks else '(none)'}")

    # Steps
    if feat.steps:
        lines.append('')
        lines.append(section_header('STEPS', inner))
        lines.append('')
        for i, step in enumerate(feat.steps, 1):
            lines.append(f"  {i}. {truncate(step, inner - 6)}")

    lines.append('')
    return lines


# ═══════════════════════════════════════════════════════════════════════════════
# INPUT & STATE
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class State:
    view: str = 'dashboard'  # dashboard | epic | feature
    selected_epic: str | None = None
    selected_feature: str | None = None
    epic_index: int = 0
    feature_index: int = 0
    scroll: int = 0


def getch() -> str:
    """Read a single character from stdin without echo."""
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
        if not ch:
            return 'q'  # EOF, treat as quit
        # Handle escape sequences (arrows, etc.)
        if ch == '\x1b':
            ch2 = sys.stdin.read(1)
            if not ch2:
                return ch
            if ch2 == '[':
                ch3 = sys.stdin.read(1)
                if not ch3:
                    return ch
                return {'A': 'up', 'B': 'down', 'C': 'right', 'D': 'left'}.get(ch3, ch)
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)


def handle_input(key: str, state: State, model: Model) -> State | None:
    """Process input and return new state, or None to quit."""
    # Quit
    if key in ('q', '\x03'):  # q or Ctrl-C
        if state.view == 'dashboard':
            return None  # Quit
        state.view = 'dashboard'
        state.selected_epic = None
        state.selected_feature = None
        return state

    # Back
    if key in ('\x1b', 'b', '\x7f'):  # Esc, b, backspace
        if state.view in ('epic', 'feature'):
            state.view = 'dashboard'
            return state

    # Navigation
    if key in ('j', 'down'):
        if state.view == 'dashboard':
            state.epic_index = min(state.epic_index + 1, len(model.epics) - 1)
    elif key in ('k', 'up'):
        if state.view == 'dashboard':
            state.epic_index = max(state.epic_index - 1, 0)

    # Enter views
    elif key in ('e', '\r', '\n'):
        if state.view == 'dashboard':
            epic_names = list(model.epics.keys())
            if epic_names:
                state.selected_epic = epic_names[state.epic_index]
                state.view = 'epic'

    elif key == 'f':
        if state.view == 'epic' and state.selected_epic:
            epic = model.epics[state.selected_epic]
            if epic.features:
                state.selected_feature = epic.features[0].id
                state.view = 'feature'

    return state


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

def render(state: State, model: Model, width: int, height: int) -> str:
    """Render current view to string."""
    if state.view == 'dashboard':
        title = 'features.json'
        footer = '[e]pic [q]uit'
        lines = view_dashboard(model, width, height)
    elif state.view == 'epic':
        title = f'epic: {state.selected_epic}'
        footer = '[f]eature [b]ack [q]uit'
        lines = view_epic(model, state.selected_epic, width, height)
    elif state.view == 'feature':
        title = state.selected_feature
        footer = '[b]ack [q]uit'
        lines = view_feature(model, state.selected_feature, width, height)
    else:
        lines = ['Unknown view']
        title = ''
        footer = ''

    framed = frame(lines, width, title, footer)
    return '\n'.join(framed)


def main():
    # Parse args
    path = 'features.json'
    if len(sys.argv) > 1:
        if sys.argv[1] in ('-h', '--help'):
            print(__doc__)
            return
        path = sys.argv[1]

    # Check file exists
    if not os.path.exists(path):
        print(f"Error: {path} not found")
        print("Run from a directory containing features.json, or specify path.")
        sys.exit(1)

    # Load data
    try:
        model = Model.load(path)
    except json.JSONDecodeError as e:
        print(f"Error parsing {path}: {e}")
        sys.exit(1)
    except KeyError as e:
        print(f"Error: missing required field {e} in {path}")
        sys.exit(1)

    # Initialize
    state = State()
    size = get_terminal_size()

    # Non-interactive mode: print dashboard once and exit
    if not sys.stdin.isatty():
        output = render(state, model, size.columns, size.lines)
        print(output)
        return

    # Clear screen and hide cursor
    print('\033[2J\033[H\033[?25l', end='')

    try:
        while True:
            size = get_terminal_size()
            output = render(state, model, size.columns, size.lines)
            # Move to top and print
            print(f'\033[H{output}', end='', flush=True)

            key = getch()
            state = handle_input(key, state, model)
            if state is None:
                break
    finally:
        # Show cursor and clear
        print('\033[?25h\033[2J\033[H', end='')


if __name__ == '__main__':
    main()
```

---

## Installation

```bash
# 1. Create ~/.local/bin if needed
mkdir -p ~/.local/bin

# 2. Save the script
# (copy fv script to ~/.local/bin/fv)

# 3. Make executable
chmod +x ~/.local/bin/fv

# 4. Add to PATH (if not already)
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc

# 5. Use it
cd /path/to/repo/with/features.json
fv
```

---

## Verification Strategy

### Phase 1
```bash
# Should print feature count without errors
./fv features.json 2>&1 | head -1
# Expected: no Python errors, shows frame
```

### Phase 2
```bash
# Visual check: all sections render
./fv
# Verify: PROGRESS bar, EPICS list, RECENT sparklines, NEXT UP features
```

### Phase 3
```bash
# Interactive: navigate through views
./fv
# Press: e (epic view), b (back), u (upcoming), q (quit)
# No crashes, smooth transitions
```

### Phase 4
```bash
# Test with edge cases
echo '[]' > /tmp/empty.json && ./fv /tmp/empty.json  # empty
echo '[{"id":"test"}]' > /tmp/minimal.json && ./fv /tmp/minimal.json  # minimal
```

### Phase 5
```bash
# From different directory
cd /tmp && fv /path/to/features.json
```

---

## Future Enhancements (Out of Scope)

- Export to HTML/SVG for sharing
- Watch mode (auto-refresh on file change)
- Diff view (compare two features.json)
- Filtering by status/epic/date
- Fuzzy search for features
