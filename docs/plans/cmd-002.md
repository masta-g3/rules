**Feature:** cmd-002 → File reservation system for parallel agents

## Relationship to PARALLEL_AGENTS.md

`docs/PARALLEL_AGENTS.md` describes a worktree-based approach — full branch isolation, separate directories, a `/finalize` merge step. That's the heavyweight solution for projects where agents modify many overlapping files.

This feature is the **lightweight alternative**: agents share a single worktree and coordinate via a lock file. Simpler setup (no branches/worktrees), works in any environment (Codex, Cursor, Claude Code), but relies on cooperative locking — not atomic. Suitable when features touch mostly disjoint files with occasional overlap.

Both can coexist. The lock file approach is opt-in via `--parallel` on `/plan-md`.

## Context Files

**Core** (directly modified):
- `AGENTS.md` — add `<file_reservations>` protocol section
- `commands/plan-md.md` — add `--parallel` flag parsing + conflict check
- `commands/execute.md` — add reserve/release cycle
- `commands/commit.md` — add cleanup step

**Reference** (existing patterns):
- `commands/autopilot.md` — `workflow.json` presence-based detection pattern
- `commands/plan-md.md` — `$1` argument variable pattern

## Design

### Architecture

```
                         ┌─────────────────────────┐
                         │ docs/plans/.file-locks.json │
                         │  (presence = toggle ON)  │
                         └────────┬────────────────┘
                                  │
        ┌─────────────────────────┼─────────────────────────┐
        │                         │                         │
   /plan-md                  /execute                  /commit
   --parallel flag           reserve → write → release  cleanup for feature
   creates lock file         poll if held              delete file if empty
   conflict check (read)
```

### Lock File Schema — `docs/plans/.file-locks.json`

```json
{
  "src/utils/format.py": { "by": "auth-001", "at": "2026-01-30T10:30:00Z" },
  "src/auth/login.py": { "by": "auth-001", "at": "2026-01-30T10:30:02Z" }
}
```

Top-level object. Key = relative file path, value = `{ "by": feature-id, "at": ISO timestamp }`.

- File absent → reservations disabled (single-agent mode)
- File present with `{}` → reservations enabled, nothing locked
- File present with entries → active locks

**Limitation:** This is cooperative/advisory locking. The jq read-modify-write isn't atomic — two agents could theoretically both see a file as unlocked simultaneously. With 15s polling intervals this is unlikely, and acceptable for a cooperative system where all agents follow the same prompts.

### Protocol Rules

1. **Reserve**: before modifying a file, add entry via jq
2. **Release**: after modification, remove entry via jq
3. **Poll**: if file is held by another feature, `sleep 15`, retry up to 5 times (75s total), then warn user
4. **Cleanup**: `/commit` removes all entries for the current feature; deletes file if empty

### Feature ID Discovery

The agent derives the feature ID from the active plan file name:
- Plan file `docs/plans/auth-001.md` → feature ID `auth-001`
- This works across all commands since the plan file is always in context

### jq Operations

**Check if file is locked by another feature:**
```bash
LOCK_FILE="docs/plans/.file-locks.json"
HOLDER=$(jq -r --arg f "$FILE" --arg me "$FEATURE_ID" \
  '.[$f] // null | if . != null and .by != $me then .by else empty end' \
  "$LOCK_FILE")
```

**Reserve a file:**
```bash
jq --arg f "$FILE" --arg id "$FEATURE_ID" --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  '.[$f] = {"by": $id, "at": $ts}' "$LOCK_FILE" > tmp.$$ && mv -f tmp.$$ "$LOCK_FILE"
```

**Release a file:**
```bash
jq --arg f "$FILE" 'del(.[$f])' "$LOCK_FILE" > tmp.$$ && mv -f tmp.$$ "$LOCK_FILE"
```

**Cleanup all entries for a feature:**
```bash
jq --arg id "$FEATURE_ID" '[to_entries[] | select(.value.by != $id)] | from_entries' \
  "$LOCK_FILE" > tmp.$$ && mv -f tmp.$$ "$LOCK_FILE"
```

**Delete file if empty:**
```bash
[ "$(jq 'length' "$LOCK_FILE")" = "0" ] && rm -f "$LOCK_FILE"
```

## Implementation Plan

### Phase 1: Protocol in AGENTS.md
[ ] Add `<file_reservations>` section to `AGENTS.md` after the `<features_json_operations>` section

Content:
- Lock file location: `docs/plans/.file-locks.json`
- Schema description (the object format above)
- Presence-based toggle: file exists = enabled, absent = disabled
- The three operations: check, reserve, release (with jq snippets)
- Poll behavior: sleep 15s, retry up to 5 times, then warn user
- Feature ID derived from active plan file name
- Rule: reserve one file at a time, right before modification; release immediately after
- Advisory nature: cooperative locking, not atomic

**Verify:** Read AGENTS.md, confirm section is well-formed and doesn't duplicate existing content.

### Phase 2: `/plan-md` — flag parsing + conflict check
[ ] Modify `commands/plan-md.md` to handle `--parallel` in `$1`

Add after "### Create Plan" (step 6, after verification strategy) and before "### Mark Feature Active":

```markdown
### Parallel Mode (File Reservations)

If `$1` contains `--parallel`:
1. Strip `--parallel` from the request string before processing
2. If `docs/plans/.file-locks.json` doesn't exist, create it with `{}`
3. Check the lock file against files listed in the Context Files section
4. Report any conflicts: "⚠ {file} is reserved by {feature-id}"
5. This is informational only — no reservations are placed during planning
```

Placement rationale: the conflict check needs the Context Files section to already be populated, so it goes after plan creation.

**Verify:** Read the modified file, confirm the new section integrates cleanly with the existing flow.

### Phase 3: `/execute` — reserve/release cycle
[ ] Modify `commands/execute.md` to add reservation logic

Add as a new section after "### Begin Implementation":

```markdown
### File Reservations (Parallel Mode)

If `docs/plans/.file-locks.json` exists, apply the reservation protocol (see AGENTS.md `<file_reservations>`) before each file modification. Derive the feature ID from the active plan file name (e.g., `auth-001.md` → `auth-001`).

1. Check if file is locked by another feature
2. If locked: sleep 15s, retry (up to 5 attempts). If still locked, report the conflict to the user and pause
3. Reserve the file (add entry with feature ID and timestamp)
4. Modify the file
5. Release the reservation (remove entry)

One file at a time. Do not batch-reserve.
```

**Verify:** Read the modified file, confirm it reads naturally within the existing implementation flow.

### Phase 4: `/commit` — cleanup
[ ] Modify `commands/commit.md` to add lock cleanup

Add after "### Update features.yaml" paragraph (after "Include features.yaml in the commit.") and before the `git add` / commit instructions:

```markdown
### Release File Reservations

If `docs/plans/.file-locks.json` exists:
1. Remove all entries where `by` matches the current feature ID
2. If the lock file is now empty (`{}`), delete it
3. Include the lock file change (or deletion) in the commit
```

**Verify:** Read the modified file, confirm cleanup runs before `git add` so the lock file state is captured in the commit.

## Verification Strategy

- **Phase 1**: Confirm AGENTS.md has the new section, no disruption to existing sections
- **Phase 2**: Trace: "If I run `/plan-md auth-001: do thing --parallel`, does the command strip the flag, create the lock file, and report conflicts after the plan is created?"
- **Phase 3**: Trace: "If lock file exists and file X is held by another feature, does the agent poll 5 times and then escalate to the user?"
- **Phase 4**: Trace: "After committing auth-001, are all auth-001 entries removed? If no other entries remain, is the file deleted and included in the commit?"
- **End-to-end**: Two hypothetical agents on different features — trace the interleaving to confirm no file gets modified by both simultaneously
