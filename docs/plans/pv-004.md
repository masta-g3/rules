# pv-004: Tree View Mode for Portfolio Visualization

**Status**: Ready for Review
**Epic**: pv
**Created**: 2026-01-24
**Depends On**: pv-001

## Overview

Add a tree-based visualization mode to the Portfolio Viewer (`pv`) that displays projects, epics, features, and their dependencies in a collapsible hierarchical structure. This provides an alternative "at a glance" view of the entire portfolio alongside the existing drill-down navigation.

## Problem Statement

The current `pv` implementation uses a **drill-down model**: Portfolio → Project → Epic → Feature. While this works well for focused exploration, it requires multiple navigation steps to understand the overall structure. Users need:

1. **High-level overview**: See all projects, their epics, and completion status at once
2. **Dependency visualization**: Understand how features relate across epics
3. **Quick navigation**: Jump directly to any level without drilling through hierarchy

## Research Findings

### UX Best Practices (Sources)

From [PatternFly Tree View Guidelines](https://www.patternfly.org/components/tree-view/design-guidelines/):
- Use tree views for **3+ levels of hierarchy** and when **selection is the main use case**
- Add **search bars for large datasets** to help users locate items quickly
- Include **badges showing child counts** on parent nodes
- Use **connecting guide lines** in compact views for easier navigation
- **Avoid for extremely deep hierarchies** with hundreds of items - use drill-down instead

From tree view accessibility research:
- **Keyboard navigation**: ↑/↓ to move, ←/→ to collapse/expand, Home/End for first/last
- **Preserve expansion state**: When collapsing a parent, remember child expansion states
- **Consistent icons**: Pick one visual metaphor (folder icon OR expand arrow, not both)

### Terminal-Specific Considerations

From [asciidag](https://github.com/sambrightman/asciidag) and git log --graph:
- Unicode box characters (│, └, ─, ├) work well for tree rendering
- Sugiyama layered layout algorithm for DAGs, but overkill for simple trees
- Performance: ascii-dag renders 1000 nodes in ~20ms with full layout

### Scalability Strategies

1. **Virtual scrolling**: Only render visible portion of tree (critical for 100+ items)
2. **Lazy expansion**: Don't compute child details until parent is expanded
3. **Collapse-by-default**: Start with top-level collapsed, let user expand what matters
4. **Search/filter**: Quick filtering reduces visual noise
5. **Multiple view modes**: Quick overview vs detailed exploration

## Design Analysis

### Current Architecture Review

```
bin/pv (1117 lines)
├── Constants (lines 40-82)
│   ├── ANSI colors, status symbols
│   └── Box drawing characters (already exists!)
├── Rendering (lines 85-187)
│   ├── ansi() - color/style text
│   ├── progress_bar() - fractional bars
│   ├── frame() - box frame with title/footer
│   └── section_header() - section dividers
├── Data Models (lines 190-500)
│   ├── Feature, Epic, Model (project-level)
│   └── ProjectSummary, Portfolio (multi-project)
├── Views (lines 500-810)
│   ├── view_portfolio() - project list
│   ├── view_project() - epic list + stats
│   ├── view_epic() - feature list
│   ├── view_feature() - single feature detail
│   └── view_help() - help overlay
├── State & Input (lines 815-973)
│   ├── State dataclass - current navigation
│   └── handle_*_input() - per-view handlers
└── Main Loop (lines 975-1117)
    ├── render() - dispatch to view
    ├── init_*_state() - entry points
    └── main() - event loop
```

**Key Insight**: The existing architecture separates views cleanly. Adding a tree view is a matter of:
1. Adding a new `view_tree()` function
2. Adding tree state to `State` dataclass
3. Adding tree-specific input handlers
4. Toggle between views with a key (e.g., `t`)

### Feasibility Assessment

**Feasible and Recommended**:
- The codebase already has box-drawing characters and ANSI rendering
- Data models (`Portfolio`, `ProjectSummary`, `Model`) already traverse the hierarchy
- Pattern of adding views is established (5 views already exist)

**Challenges to Address**:
1. **Screen real estate**: Terminal width limits how deep we can indent
2. **Large portfolios**: 50+ projects × 5+ epics × 10+ features = 2500+ potential lines
3. **Dependencies**: Cross-cutting lines (feature A depends on feature B in different epic) are complex

## Proposed Solution: Hybrid Tree View

Instead of a full tree with all dependencies rendered as edges, implement a **collapsible outline** with dependency annotations:

```
┌─ tree ──────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  ▼ rules                          12/15 ████████████░░░░ 80%               │
│    ▼ pv                           1/4   ████░░░░░░░░░░░░ 25%               │
│        ✓ pv-001 Unified viewer                                             │
│        ○ pv-002 Edit mode                    ← pv-001                      │
│        ○ pv-003 Archive epics                ← pv-002                      │
│        ○ pv-004 Tree view                    ← pv-001                      │
│    ► auth                         8/8   ████████████████ 100%  (collapsed) │
│    ► core                         3/3   ████████████████ 100%              │
│  ▼ other-project                  5/20  ████░░░░░░░░░░░░ 25%               │
│    ▼ api                          2/8   ████░░░░░░░░░░░░ 25%               │
│        ◉ api-005 Rate limiting    ← api-001, api-002                       │
│        ○ api-006 Caching                     ← api-005                     │
│        ...                                                                  │
│                                                                             │
│  Showing 3/12 projects, 4/15 epics, 8/48 features                          │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ [←/→]expand [j/k]move [/]search [t]table view [q]uit                       │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Key Design Decisions

1. **Outline, not graph**: Dependencies shown as annotations (`← parent`) rather than crossing lines
2. **Three levels visible**: Project → Epic → Feature (no deeper nesting)
3. **Collapse by default**: Projects expanded, epics collapsed initially
4. **Progress bars inline**: Each level shows completion status
5. **Search/filter**: `/` key activates search mode
6. **Toggle view**: `t` key switches between tree and existing table views

### Visual Hierarchy

```
Project (bold, project color)
  └─ Epic (epic color, indented 2 spaces)
      └─ Feature (status color, indented 4 spaces)
           └─ Dependency annotation (muted, right-aligned)
```

### Navigation Model

| Key | Action |
|-----|--------|
| `j/k` or `↓/↑` | Move cursor |
| `→` or `l` or `Enter` | Expand / drill into |
| `←` or `h` | Collapse |
| `o` | Toggle expand/collapse |
| `O` | Expand all under cursor |
| `M` | Collapse all |
| `/` | Enter search mode |
| `n/N` | Next/prev search result |
| `t` | Toggle to table view |
| `z` | Zoom: show only cursor subtree |
| `Esc` | Exit search / zoom / tree view |

### Handling Scale

#### Problem: 50 projects × 5 epics × 10 features = 2500 lines

**Solutions (in order of implementation priority)**:

1. **Collapse by default** (Phase 1)
   - Only project names visible initially: 50 lines max
   - User expands what they need

2. **Filter mode** (Phase 1)
   - `a` to toggle "show all" vs "show open work only"
   - Hides completed projects/epics by default

3. **Search** (Phase 2)
   - `/` to search, results highlighted
   - Auto-expands path to matches

4. **Virtual scrolling** (Phase 3, if needed)
   - Only render visible portion
   - Track scroll offset separately from expansion state

### Dependency Visualization

**Option A: Inline annotation** (Recommended - simpler, fits terminal width)
```
○ pv-004 Tree view                    ← pv-001
```

**Option B: Separate dependency section** (For deep dependency chains)
```
  DEPENDENCIES ═══════════════════════════
  pv-002 ← pv-001
  pv-003 ← pv-002
  pv-004 ← pv-001
```

**Option C: Focus mode** (On demand - press `d` on a feature)
```
  ┌─ pv-004 dependencies ─┐
  │ ◉ pv-001 (done)       │
  │   └─▸ pv-004 (you)    │
  │                       │
  │ Blocks:               │
  │   (nothing)           │
  └───────────────────────┘
```

We'll implement **Option A** for Phase 1, with **Option C** as a Phase 3 enhancement.

## Implementation Plan

### Phase 1: Core Tree View

**Goal**: Basic collapsible tree with project/epic/feature hierarchy

#### 1.1 Data Structures

**Design Decision**: Use a simple flat cursor index instead of path-based cursor. The flattened list is the source of truth for navigation - simpler and avoids path/index conversion complexity.

```python
@dataclass
class TreeNode:
    """Unified node for tree rendering."""
    type: str  # 'project' | 'epic' | 'feature'
    id: str
    label: str
    children: list['TreeNode'] = field(default_factory=list)
    expanded: bool = False
    data: Any = None  # ProjectSummary | Epic | Feature
    parent: 'TreeNode | None' = None  # For navigation back to parent
    project_ref: ProjectSummary | None = None  # For drilling into feature detail

    @property
    def has_children(self) -> bool:
        return len(self.children) > 0

@dataclass
class TreeState:
    """State for tree view mode."""
    root: TreeNode  # Virtual root containing all projects
    cursor_idx: int = 0  # Simple flat index - no path conversion needed
    scroll_offset: int = 0
    show_all: bool = False  # Include completed items
```

Add to existing `State`:
```python
@dataclass
class State:
    # ... existing fields ...
    tree: TreeState | None = None
    view: str = 'portfolio'  # Add 'tree' as valid value
```

#### 1.2 Tree Building Functions

**Performance Note**: Epic children are populated lazily on first expansion. This avoids loading all features.json files upfront for large portfolios.

```python
def build_tree(portfolio: Portfolio, show_all: bool = False) -> TreeNode:
    """Build tree from portfolio data. Epic children loaded lazily on expand."""
    root = TreeNode(type='root', id='root', label='Portfolio')

    for proj in portfolio.projects:
        if not show_all and proj.is_complete:
            continue

        proj_node = TreeNode(
            type='project',
            id=proj.path,
            label=proj.name,
            data=proj,
            expanded=True,  # Projects expanded by default
            parent=root,
            project_ref=proj,
        )

        # Only add epic stubs - children loaded on expand
        # Use cached project summary data for epic names (no load_detail yet)
        for epic_name in proj.epics:
            epic_node = TreeNode(
                type='epic',
                id=f"{proj.path}:{epic_name}",
                label=epic_name,
                data=None,  # Loaded on expand
                expanded=False,
                parent=proj_node,
                project_ref=proj,
            )
            proj_node.children.append(epic_node)

        if proj_node.children or show_all:
            root.children.append(proj_node)

    return root


def expand_epic(node: TreeNode, show_all: bool = False) -> None:
    """Populate epic children on first expansion (lazy load)."""
    if node.type != 'epic' or node.children:  # Already populated
        return

    proj = node.project_ref
    if not proj:
        return

    model = proj.load_detail()
    epic = model.epics.get(node.label)
    if not epic:
        return

    node.data = epic  # Store loaded epic data

    for feat in sorted(epic.features, key=lambda f: f.id):
        if not show_all and feat.is_done:
            continue

        feat_node = TreeNode(
            type='feature',
            id=feat.id,
            label=f"{feat.id} {feat.title}",
            data=feat,
            parent=node,
            project_ref=proj,
        )
        node.children.append(feat_node)


def expand_all(node: TreeNode, show_all: bool = False) -> None:
    """Recursively expand node and all descendants."""
    if node.type == 'epic' and not node.children:
        expand_epic(node, show_all)
    node.expanded = True
    for child in node.children:
        expand_all(child, show_all)


def collapse_all(node: TreeNode) -> None:
    """Recursively collapse node and all descendants."""
    node.expanded = False
    for child in node.children:
        collapse_all(child)
```

#### 1.3 Tree Rendering

```python
def flatten_tree(node: TreeNode, depth: int = 0, visible_only: bool = True) -> list[tuple[int, TreeNode]]:
    """Flatten tree to (depth, node) pairs for rendering."""
    result = []
    if node.type != 'root':
        result.append((depth, node))

    if node.type == 'root' or node.expanded:
        for child in node.children:
            result.extend(flatten_tree(child, depth + 1 if node.type != 'root' else 0, visible_only))

    return result


def render_tree_node(depth: int, node: TreeNode, is_cursor: bool, width: int) -> str:
    """Render single tree node line."""
    indent = '  ' * depth

    # Expand/collapse indicator
    if node.has_children:
        arrow = '▼ ' if node.expanded else '► '
    else:
        arrow = '  '

    # Status symbol for features
    if node.type == 'feature':
        feat = node.data
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        prefix = ansi(sym, color) + ' '
    else:
        prefix = ''

    # Label with appropriate color
    if node.type == 'project':
        label = ansi(node.label, COLOR_PROJECT, bold=is_cursor)
    elif node.type == 'epic':
        label = ansi(node.label, COLOR_EPIC, bold=is_cursor)
    else:
        label = node.label

    # Progress bar for project/epic
    progress = ''
    if node.type == 'project':
        proj = node.data
        bar = progress_bar(proj.done, proj.total, 12)
        pct = f"{proj.percent:.0f}%"
        progress = f"  {proj.done}/{proj.total} {bar} {pct}"
    elif node.type == 'epic':
        epic = node.data
        bar = progress_bar(epic.done, epic.total, 12)
        pct = f"{epic.percent:.0f}%"
        progress = f"  {epic.done}/{epic.total} {bar} {pct}"

    # Dependencies for features
    deps = ''
    if node.type == 'feature' and node.data.depends_on:
        dep_ids = ', '.join(node.data.depends_on[:2])
        if len(node.data.depends_on) > 2:
            dep_ids += '...'
        deps = ansi(f" ← {dep_ids}", COLOR_DEP)

    # Cursor indicator
    cursor = ansi('▸', COLOR_PROJECT, bold=True) if is_cursor else ' '

    # Assemble line
    line = f"{cursor}{indent}{arrow}{prefix}{label}{progress}{deps}"
    return line


def view_tree(state: State, width: int, height: int) -> list[str]:
    """Render tree view."""
    lines = []
    inner = width - 4

    if not state.tree or not state.tree.root:
        return ['  No tree data']

    flat = flatten_tree(state.tree.root)

    # Handle empty tree
    if not flat:
        lines.append('')
        filter_msg = '(all items filtered)' if not state.tree.show_all else '(no projects)'
        lines.append(f"  {ansi(f'Empty tree {filter_msg}', COLOR_MUTED)}")
        lines.append(f"  {ansi('Press [a] to show all', COLOR_MUTED)}")
        return lines

    # Calculate visible window
    visible_height = max(1, height - 6)  # Account for frame + footer
    cursor_idx = state.tree.cursor_idx
    scroll = state.tree.scroll_offset

    # Adjust scroll to keep cursor visible
    if cursor_idx < scroll:
        scroll = cursor_idx
    elif cursor_idx >= scroll + visible_height:
        scroll = cursor_idx - visible_height + 1
    state.tree.scroll_offset = max(0, scroll)

    # Render visible portion
    for i, (depth, node) in enumerate(flat[scroll:scroll + visible_height]):
        is_cursor = (i + scroll == cursor_idx)
        line = render_tree_node(depth, node, is_cursor, inner)
        lines.append(line)

    # Stats footer
    total_visible = len(flat)
    lines.append('')
    lines.append(f"  {ansi(f'{total_visible} items', COLOR_MUTED)}")

    return lines
```

#### 1.4 Tree Navigation

**Simplified cursor model**: Use flat index directly. Find parent by walking flat list backward.

```python
def find_parent_idx(flat: list[tuple[int, TreeNode]], cursor_idx: int) -> int:
    """Find index of parent node in flattened list."""
    if cursor_idx <= 0 or cursor_idx >= len(flat):
        return -1

    current_depth, current_node = flat[cursor_idx]

    # Walk backward to find first node at shallower depth
    for i in range(cursor_idx - 1, -1, -1):
        depth, node = flat[i]
        if depth < current_depth:
            return i

    return -1


def handle_tree_input(key: str, state: State) -> State:
    """Handle input in tree view."""
    if not state.tree:
        return state

    flat = flatten_tree(state.tree.root)

    # Handle empty tree (all items filtered out)
    if not flat:
        if key == 't':
            state.view = 'portfolio'
        elif key == 'a':
            state.tree.show_all = not state.tree.show_all
            state.tree.root = build_tree(state.portfolio, state.tree.show_all)
            state.tree.cursor_idx = 0
        return state

    # Clamp cursor to valid range
    cursor_idx = min(state.tree.cursor_idx, len(flat) - 1)
    cursor_idx = max(0, cursor_idx)
    state.tree.cursor_idx = cursor_idx

    if key in ('j', 'down'):
        if cursor_idx < len(flat) - 1:
            state.tree.cursor_idx = cursor_idx + 1

    elif key in ('k', 'up'):
        if cursor_idx > 0:
            state.tree.cursor_idx = cursor_idx - 1

    elif key in ('l', 'right', '\r', '\n'):
        _, node = flat[cursor_idx]
        if node.type == 'epic' and not node.expanded:
            expand_epic(node, state.tree.show_all)
            node.expanded = True
        elif node.has_children and not node.expanded:
            node.expanded = True
        elif node.type == 'feature':
            # Drill into feature detail - set up full context
            proj = node.project_ref
            if proj:
                proj.load_detail()
                state.current_project = proj
                state.current_epic = node.parent.label if node.parent else None
                state.current_feature = node.data.id
                state.view = 'feature'

    elif key in ('h', 'left'):
        _, node = flat[cursor_idx]
        if node.expanded:
            node.expanded = False
        else:
            parent_idx = find_parent_idx(flat, cursor_idx)
            if parent_idx >= 0:
                state.tree.cursor_idx = parent_idx

    elif key == 'o':
        _, node = flat[cursor_idx]
        if node.type == 'epic' and not node.expanded:
            expand_epic(node, state.tree.show_all)
        if node.has_children:
            node.expanded = not node.expanded

    elif key == 'O':
        _, node = flat[cursor_idx]
        expand_all(node, state.tree.show_all)

    elif key == 'M':
        collapse_all(state.tree.root)
        state.tree.cursor_idx = 0

    elif key == 't':
        state.view = 'portfolio'

    elif key == 'a':
        state.tree.show_all = not state.tree.show_all
        state.tree.root = build_tree(state.portfolio, state.tree.show_all)
        state.tree.cursor_idx = 0

    return state
```

#### 1.5 Integration Points

Update `State`:
```python
@dataclass
class State:
    view: str = 'portfolio'  # Add 'tree' as option
    # ... existing fields ...
    tree: TreeState | None = None
```

Update `render()`:
```python
def render(state: State, width: int, height: int) -> str:
    if state.view == 'tree':
        title = 'tree'
        footer = '[h/l]expand [o]toggle [t]table [a]all [q]uit'
        lines = view_tree(state, width, height)
    elif state.view == 'portfolio':
        # ... existing code ...
```

Update `handle_portfolio_input()`:
```python
def handle_portfolio_input(key: str, state: State) -> State:
    # ... existing code ...
    elif key == 't':
        # Switch to tree view
        state.tree = TreeState(
            root=build_tree(state.portfolio, state.show_all),
            cursor_path=[0],
        )
        state.view = 'tree'
    # ...
```

### Phase 2: Search & Filter

**Goal**: Add search to quickly find items in large trees

#### 2.1 Search State

```python
@dataclass
class TreeState:
    # ... existing fields ...
    search_mode: bool = False
    search_query: str = ''
    search_matches: list[tuple[int, TreeNode]] = field(default_factory=list)
    search_index: int = 0
```

#### 2.2 Search Implementation

```python
def search_tree(node: TreeNode, query: str, path: list = None) -> list[tuple[list, TreeNode]]:
    """Find all nodes matching query."""
    if path is None:
        path = []

    matches = []

    if node.type != 'root':
        # Check if this node matches
        if query.lower() in node.label.lower():
            matches.append((path.copy(), node))
        # Also check feature description
        if node.type == 'feature' and node.data.description:
            if query.lower() in node.data.description.lower():
                matches.append((path.copy(), node))

    # Search children
    for i, child in enumerate(node.children):
        child_path = path + [i]
        matches.extend(search_tree(child, query, child_path))

    return matches


def expand_path_to(root: TreeNode, path: list[int]) -> None:
    """Expand all nodes along path."""
    node = root
    for idx in path:
        node.expanded = True
        if idx < len(node.children):
            node = node.children[idx]
```

#### 2.3 Search UI

```python
def handle_tree_search_input(key: str, state: State) -> State:
    """Handle input during search mode."""
    ts = state.tree

    if key == '\x1b':  # Escape
        ts.search_mode = False
        ts.search_query = ''
        ts.search_matches = []
    elif key == '\r':  # Enter - confirm search
        ts.search_mode = False
        if ts.search_matches:
            # Jump to first match
            path, _ = ts.search_matches[0]
            expand_path_to(ts.root, path)
            ts.cursor_path = path
    elif key == '\x7f':  # Backspace
        ts.search_query = ts.search_query[:-1]
        ts.search_matches = search_tree(ts.root, ts.search_query)
    elif key == 'n' and not ts.search_mode:  # Next match
        if ts.search_matches:
            ts.search_index = (ts.search_index + 1) % len(ts.search_matches)
            path, _ = ts.search_matches[ts.search_index]
            expand_path_to(ts.root, path)
            ts.cursor_path = path
    elif key == 'N' and not ts.search_mode:  # Prev match
        if ts.search_matches:
            ts.search_index = (ts.search_index - 1) % len(ts.search_matches)
            path, _ = ts.search_matches[ts.search_index]
            expand_path_to(ts.root, path)
            ts.cursor_path = path
    elif len(key) == 1 and key.isprintable():
        ts.search_query += key
        ts.search_matches = search_tree(ts.root, ts.search_query)
        ts.search_index = 0

    return state
```

### Phase 3: Zoom Mode (Optional Enhancement)

**Goal**: Add zoom mode to focus on a subtree. Scoped to zoom only - other enhancements (dependency popup, stalled indicators) can be separate tickets if needed.

#### 3.1 Focus Mode (Zoom)

**Simplified approach**: Instead of swapping roots, add a `zoomed_node` field and filter in `flatten_tree()`.

```python
@dataclass
class TreeState:
    # ... existing fields ...
    zoomed_node: TreeNode | None = None  # If set, only show this subtree


def flatten_tree(node: TreeNode, depth: int = 0, zoomed: TreeNode | None = None) -> list[tuple[int, TreeNode]]:
    """Flatten tree. If zoomed is set, only include that subtree."""
    result = []

    # If zooming, skip until we reach the zoomed node
    if zoomed and node != zoomed and node.type != 'root':
        # Check if zoomed is a descendant
        if not is_descendant(zoomed, node):
            return result

    if node.type != 'root':
        result.append((depth, node))

    if node.type == 'root' or node.expanded:
        for child in node.children:
            result.extend(flatten_tree(child, depth + 1 if node.type != 'root' else 0, zoomed))

    return result


def is_descendant(target: TreeNode, of: TreeNode) -> bool:
    """Check if target is a descendant of 'of' node."""
    for child in of.children:
        if child == target or is_descendant(target, child):
            return True
    return False
```

Add zoom toggle to input handler:
```python
elif key == 'z':
    flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
    _, node = flat[cursor_idx]
    if state.tree.zoomed_node == node:
        state.tree.zoomed_node = None  # Unzoom
    else:
        state.tree.zoomed_node = node  # Zoom to cursor
    state.tree.cursor_idx = 0
```

Update `view_tree()` to pass zoomed node:
```python
flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
```

#### 3.2 Dependency Focus Popup (Separate Ticket)

This could be a follow-up ticket (pv-005). When pressing `d` on a feature, show a popup with its dependency graph:

```python
def view_dependency_popup(feat: Feature, model: Model, width: int) -> list[str]:
    """Render dependency mini-graph."""
    lines = []
    popup_width = min(40, width - 10)

    lines.append(f"┌─ {feat.id} ─" + "─" * (popup_width - len(feat.id) - 5) + "┐")

    # Show dependencies (what this depends on)
    lines.append("│ Depends on:")
    if feat.depends_on:
        for dep_id in feat.depends_on:
            dep = model.features.get(dep_id)
            if dep:
                sym = STATUS_SYMBOL.get(dep.status, '?')
                status_color = STATUS_COLOR.get(dep.status, 0)
                lines.append(f"│   {ansi(sym, status_color)} {dep_id}")
            else:
                lines.append(f"│   ? {dep_id} (not found)")
    else:
        lines.append(f"│   {ansi('(none)', COLOR_MUTED)}")

    lines.append("│")

    # Show dependents (what depends on this)
    lines.append("│ Blocks:")
    unlocks = model.unlocks(feat.id)
    if unlocks:
        for unlock_id in unlocks:
            lines.append(f"│   → {unlock_id}")
    else:
        lines.append(f"│   {ansi('(none)', COLOR_MUTED)}")

    lines.append("└" + "─" * (popup_width - 2) + "┘")

    return lines
```

## File Changes Summary

| File | Changes |
|------|---------|
| `bin/pv` | Add TreeNode, TreeState dataclasses; add view_tree(), build_tree(), handle_tree_input(); update State, render(), input handlers |

**Estimated additions**: ~250 lines (Phase 1-2), ~50 more for Phase 3
**No new files required**

### Key Design Changes from Review
1. **Simple cursor**: Using flat index instead of path - avoids complex path↔index conversion
2. **Lazy loading**: Epic children loaded on first expand, not during tree build
3. **Parent references**: Each node stores parent pointer for navigation and context
4. **Empty state handling**: Graceful handling when all items filtered out
5. **Zoom simplification**: Filter in `flatten_tree()` instead of swapping roots
6. **Scoped Phase 3**: Only zoom mode - dependency popup moved to separate ticket

## Implementation Checklist

### Phase 1: Core Tree View
- [ ] Add `TreeNode` and `TreeState` dataclasses
- [ ] Implement `build_tree()` from Portfolio
- [ ] Implement `flatten_tree()` for rendering
- [ ] Implement `render_tree_node()` with colors and progress
- [ ] Implement `view_tree()` with scroll handling
- [ ] Implement tree navigation (j/k/h/l/o/O/M)
- [ ] Add `t` key toggle in portfolio view
- [ ] Add `t` key toggle back to portfolio from tree
- [ ] Update `render()` to dispatch to tree view
- [ ] **Verify**: Tree displays, navigation works, toggle between views works

### Phase 2: Search & Filter
- [ ] Add search state fields to TreeState
- [ ] Implement `search_tree()` recursive search
- [ ] Implement `expand_path_to()` for revealing matches
- [ ] Add `/` to enter search mode
- [ ] Add incremental search with live highlighting
- [ ] Add `n/N` for next/prev match
- [ ] Add `a` toggle for show all (including completed)
- [ ] **Verify**: Search finds items, expands paths, highlights matches

### Phase 3: Zoom Mode (Optional)
- [ ] Add `zoomed_node` field to TreeState
- [ ] Update `flatten_tree()` to filter when zoomed
- [ ] Add `z` key to toggle zoom on cursor
- [ ] Update footer to show zoom state
- [ ] **Verify**: Zoom focuses on subtree, `z` again unzooms

### Future Enhancements (Separate Tickets)
- Dependency popup (`d` key) - pv-005
- Visual connection lines (├, │, └)
- Stalled indicators in tree view

## Verification Strategy

### Phase 1 Verification
1. **Portfolio scan**: Run `pv` on ~/Code, verify projects load
2. **View toggle**: Press `t`, verify tree displays with correct hierarchy
3. **Navigation**: Use j/k/h/l to navigate, verify cursor moves correctly
4. **Expand/collapse**: Press `o` on epic, verify children show/hide
5. **Progress bars**: Verify project and epic progress bars match actual counts
6. **Dependencies**: Verify feature dependencies show as `← dep-id`
7. **Return toggle**: Press `t` again, verify return to portfolio view
8. **Edge cases**: Empty portfolio, single project, no epics

### Phase 2 Verification
1. **Search activation**: Press `/`, verify search mode activates
2. **Incremental search**: Type query, verify matches highlighted
3. **Path expansion**: Search for nested item, verify path expands
4. **Navigation**: Use `n/N` to cycle through matches
5. **Exit search**: Press Esc, verify search mode exits
6. **Show all toggle**: Press `a`, verify completed items appear/disappear

### Phase 3 Verification
1. **Zoom**: Press `z` on project, verify only that subtree shows
2. **Unzoom**: Press `z` again, verify full tree restores
3. **Cursor reset**: Verify cursor resets to 0 on zoom/unzoom
4. **Footer**: Verify footer shows "[zoomed]" indicator when zoomed

## Alternatives Considered

### Alternative A: Full DAG Rendering with Crossing Lines

Render dependencies as actual graph edges crossing the tree:

```
pv-001 ───────────────┐
pv-002 ←──────────────┤
pv-003 ←──────────────┘
       ←──────────────── pv-002
```

**Rejected because**:
- Complex layout algorithm needed (Sugiyama)
- Terminal width constraints make crossing lines unreadable
- Dependencies often cross epics, making visual spaghetti

### Alternative B: Separate Dependency Panel

Split screen: tree on left, dependency graph on right

```
│ Tree                    │ Dependencies        │
│ ▼ rules                 │    pv-001           │
│   ▼ pv                  │      ↓              │
│     ✓ pv-001            │    pv-002 ──→ pv-003│
│     ○ pv-002 ←          │      ↓              │
```

**Rejected because**:
- Halves available width for each panel
- Dependency graph still needs complex layout
- Complexity not warranted for typical use case

### Alternative C: Miller Columns (3-pane)

macOS Finder-style columns: Projects | Epics | Features

**Rejected because**:
- Already have drill-down navigation for this
- Tree view goal is overview, not navigation
- Width constraints with 3 columns

## Sources & References

- [PatternFly Tree View Guidelines](https://www.patternfly.org/components/tree-view/design-guidelines/)
- [asciidag - ASCII DAG renderer](https://github.com/sambrightman/asciidag)
- [tui-tree-widget - Ratatui tree component](https://crates.io/crates/tui-tree-widget)
- [Git log --graph for branch visualization](https://tech.serhatteker.com/post/2021-02/git-log-tree/)
- [awesome-tuis - TUI project collection](https://github.com/rothgar/awesome-tuis)
