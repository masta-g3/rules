#!/usr/bin/env python3
"""
pv - Portfolio & Feature Viewer

Unified TUI for features.yaml tracking.
Navigate: Portfolio → Project → Epic → Feature

Usage:
    pv                    # Scan ~/Code, portfolio view
    pv /path              # Scan specific directory
    pv features.yaml      # Project view for specific file
    fv                    # Alias: project view for ./features.yaml

Navigation:
    j/k or ↑/↓  Move selection
    Enter       Drill down (project/epic/feature)
    b/Esc       Go back
    s           Cycle sort mode (portfolio)
    f           Cycle filter (open/all/active/stalled/archived)
    h/?         Show help
    q           Quit
"""

from __future__ import annotations

import json
import os
import re
import sys
import tty
import termios

import yaml
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from shutil import get_terminal_size
from typing import Any


# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

BACKLOG_FILE = 'features.yaml'

ANSI_ESCAPE = re.compile(r'\033\[[0-9;]*m')


# Custom loader: prevents PyYAML from parsing dates as datetime.date.
# Without this, yq-written `created_at: 2026-01-15` becomes datetime.date,
# breaking string comparisons throughout pv.
class SafeYAMLLoader(yaml.SafeLoader):
    pass


SafeYAMLLoader.yaml_implicit_resolvers = {
    k: [(tag, regexp) for tag, regexp in v if tag != 'tag:yaml.org,2002:timestamp']
    for k, v in yaml.SafeLoader.yaml_implicit_resolvers.copy().items()
}

STATUS_DONE = {'done', 'complete'}
STATUS_ACTIVE = {'in_progress'}
STATUS_PENDING = {'pending'}

STATUS_SYMBOL = {
    'done': '✓', 'complete': '✓',
    'in_progress': '◉',
    'pending': '○',
    'abandoned': '✗',
    'superseded': '↷',
}

STATUS_COLOR = {
    'done': 34, 'complete': 34,
    'in_progress': 33,
    'pending': 245,
    'abandoned': 238,
    'superseded': 238,
}

COLOR_MUTED = 240
COLOR_BAR_ACTIVE = 75     # lighter blue for active in progress bars
COLOR_BAR_ABANDONED = 236 # dark gray for abandoned/superseded
COLOR_EPIC = 39
COLOR_PROJECT = 39
COLOR_DEP = 213
COLOR_HEALTHY = 34
COLOR_ACTIVE = 33
COLOR_STALLED = 131
COLOR_BORDER = 237
COLOR_FOOTER = 245
COLOR_HOTKEY = 252

BOX = {
    'tl': '┌', 'tr': '┐', 'bl': '└', 'br': '┘',
    'h': '─', 'v': '│', 'title': '═',
}

BLOCKS = ' ▏▎▍▌▋▊▉█'
SORT_MODES = ['open', 'modified', 'total', 'completion']
FILTER_MODES = ['open', 'all', 'active', 'stalled', 'archived']
STALL_DAYS = 14

# Edit mode
EDITABLE_FIELDS = ['title', 'status', 'priority', 'description', 'depends_on', 'notes']
STATUS_OPTIONS = ['pending', 'in_progress', 'done', 'abandoned', 'superseded']

# Creation mode
CREATION_FIELDS_FEATURE = ['title', 'status', 'priority', 'description', 'depends_on']
CREATION_FIELDS_EPIC = ['name']


# ═══════════════════════════════════════════════════════════════════════════════
# ANSI RENDERING
# ═══════════════════════════════════════════════════════════════════════════════

def ansi(text: str, color: int | None = None, bold: bool = False, dim: bool = False) -> str:
    if not (color or bold or dim):
        return text
    codes = []
    if bold:
        codes.append('1')
    if dim:
        codes.append('2')
    if color:
        codes.append(f'38;5;{color}')
    return f"\033[{';'.join(codes)}m{text}\033[0m"


def visible_len(text: str) -> int:
    return len(ANSI_ESCAPE.sub('', text))


def progress_bar(done: int, total: int, width: int = 40,
                 active: int = 0, pending: int = 0, abandoned: int = 0) -> str:
    if total == 0:
        return ansi('░' * width, COLOR_MUTED)

    # Ensure non-zero counts get at least 1 pixel
    counts = [done, active, pending, abandoned]
    widths = [max(1, int(c / total * width)) if c > 0 else 0 for c in counts]

    # Adjust largest segment to fit total width
    diff = sum(widths) - width
    if diff != 0:
        largest = max(range(4), key=lambda i: widths[i])
        widths[largest] -= diff

    return (ansi('█' * widths[0], COLOR_HEALTHY) +
            ansi('█' * widths[1], COLOR_BAR_ACTIVE) +
            ansi('░' * widths[2], COLOR_MUTED) +
            ansi('░' * widths[3], COLOR_BAR_ABANDONED))


def truncate(text: str, width: int) -> str:
    if len(text) <= width:
        return text
    return text[:width - 1] + '…'


def style_footer(text: str) -> str:
    """Style footer: readable text with brighter hotkey indicators."""
    parts = re.split(r'(\[[^\]]+\])', text)
    result = ''
    for part in parts:
        if part.startswith('[') and part.endswith(']'):
            result += ansi(part, COLOR_HOTKEY)
        else:
            result += ansi(part, COLOR_FOOTER)
    return result


def frame(lines: list[str], width: int, title: str = '', footer: str = '') -> list[str]:
    inner_width = width - 2
    result = []

    if title:
        title_str = f' {title} '
        pad_left = 2
        pad_right = max(0, inner_width - len(title_str) - pad_left)
        top = BOX['tl'] + BOX['h'] * pad_left + title_str + BOX['h'] * pad_right + BOX['tr']
    else:
        top = BOX['tl'] + BOX['h'] * inner_width + BOX['tr']
    result.append(ansi(top, COLOR_BORDER))

    for line in lines:
        vlen = visible_len(line)
        padding = max(0, inner_width - vlen)
        result.append(ansi(BOX['v'], COLOR_BORDER) + line + ' ' * padding + ansi(BOX['v'], COLOR_BORDER))

    if footer:
        footer_plain = f' {footer} '
        pad_right = 2
        pad_left = max(0, inner_width - len(footer_plain) - pad_right)
        bottom = (ansi(BOX['bl'] + BOX['h'] * pad_left, COLOR_BORDER) +
                  style_footer(footer_plain) +
                  ansi(BOX['h'] * pad_right + BOX['br'], COLOR_BORDER))
    else:
        bottom = ansi(BOX['bl'] + BOX['h'] * inner_width + BOX['br'], COLOR_BORDER)
    result.append(bottom)

    return result


def section_header(title: str, width: int) -> str:
    line_len = max(0, width - len(title) - 4)
    return f"  {ansi(title, bold=True)} {ansi(BOX['title'] * line_len, COLOR_MUTED)}"


def getch() -> str:
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
        if not ch:
            return 'q'
        if ch == '\x1b':
            ch2 = sys.stdin.read(1)
            if not ch2:
                return ch
            if ch2 == '[':
                ch3 = sys.stdin.read(1)
                if not ch3:
                    return ch
                return {'A': 'up', 'B': 'down', 'C': 'right', 'D': 'left'}.get(ch3, ch)
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)


# ═══════════════════════════════════════════════════════════════════════════════
# DATA MODEL - FEATURES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class Feature:
    id: str
    status: str
    title: str = ''
    description: str = ''
    epic: str | None = None
    depends_on: list[str] = field(default_factory=list)
    priority: int | None = None
    created_at: str | None = None
    spec_file: str | None = None
    steps: list[str] = field(default_factory=list)
    discovered_from: str | None = None
    notes: str | None = None

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Feature:
        title = d.get('title') or d.get('name') or d.get('description', '')[:60] or d['id']
        priority = d.get('priority')
        if isinstance(priority, str):
            priority = {'low': 3, 'medium': 2, 'high': 1, 'critical': 0}.get(priority.lower())

        return cls(
            id=d['id'],
            status=d.get('status', 'pending'),
            title=title,
            description=d.get('description', ''),
            epic=d.get('epic'),
            depends_on=d.get('depends_on', []),
            priority=priority,
            created_at=d.get('created_at'),
            spec_file=d.get('spec_file'),
            steps=d.get('steps', []),
            discovered_from=d.get('discovered_from'),
            notes=d.get('notes'),
        )

    @property
    def is_done(self) -> bool:
        return self.status in STATUS_DONE

    @property
    def is_active(self) -> bool:
        return self.status in STATUS_ACTIVE

    @property
    def is_pending(self) -> bool:
        return self.status in STATUS_PENDING


@dataclass
class Epic:
    name: str
    features: list[Feature] = field(default_factory=list)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features if f.is_pending)

    @property
    def abandoned(self) -> int:
        return sum(1 for f in self.features
                   if f.status in ('abandoned', 'superseded'))

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def percent(self) -> float:
        return (self.done / self.total * 100) if self.total else 0


@dataclass
class Model:
    features: dict[str, Feature]
    epics: dict[str, Epic]
    activity: dict[str, list[str]]

    @classmethod
    def load(cls, path: str) -> Model:
        with open(path) as f:
            data = yaml.load(f, Loader=SafeYAMLLoader) or []

        features = {}
        epics: dict[str, Epic] = {}
        activity: dict[str, list[str]] = {}

        for item in data:
            feat = Feature.from_dict(item)
            features[feat.id] = feat

            epic_name = feat.epic or '(no epic)'
            if epic_name not in epics:
                epics[epic_name] = Epic(name=epic_name)
            epics[epic_name].features.append(feat)

            if feat.created_at:
                if feat.created_at not in activity:
                    activity[feat.created_at] = []
                activity[feat.created_at].append(feat.id)

        epics = dict(sorted(epics.items(), key=lambda x: (-x[1].percent, x[0])))
        return cls(features=features, epics=epics, activity=activity)

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features.values() if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features.values() if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features.values() if f.is_pending)

    @property
    def abandoned(self) -> int:
        return sum(1 for f in self.features.values()
                   if f.status in ('abandoned', 'superseded'))

    def upcoming(self) -> list[Feature]:
        upcoming = [f for f in self.features.values() if f.is_active or f.is_pending]
        return sorted(upcoming, key=lambda f: (
            0 if f.is_active else 1,
            f.priority if f.priority is not None else 999,
            f.created_at or '9999',
        ))

    def unlocks(self, feature_id: str) -> list[str]:
        return [f.id for f in self.features.values() if feature_id in f.depends_on]


# ═══════════════════════════════════════════════════════════════════════════════
# DATA MODEL - PORTFOLIO
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class ProjectSummary:
    path: str
    name: str
    total: int = 0
    done: int = 0
    active: int = 0
    pending: int = 0
    abandoned: int = 0
    epics: set = field(default_factory=set)
    open_epics: set = field(default_factory=set)
    last_modified: datetime | None = None
    oldest_pending_date: str | None = None
    worked_today: bool = False
    archived: bool = False
    _detail: Model | None = field(default=None, repr=False)

    @classmethod
    def from_path(cls, features_path: str) -> ProjectSummary | None:
        try:
            with open(features_path) as f:
                data = yaml.load(f, Loader=SafeYAMLLoader) or []
        except (yaml.YAMLError, IOError):
            return None

        if not isinstance(data, list):
            return None

        path = Path(features_path).parent
        name = path.name

        proj = cls(path=str(path), name=name)
        proj.archived = os.path.exists(os.path.join(proj.path, '.archived'))
        proj.last_modified = datetime.fromtimestamp(os.path.getmtime(features_path))
        proj.worked_today = proj.last_modified.date() == datetime.now().date()

        for item in data:
            status = item.get('status', 'pending')
            epic = item.get('epic')
            created = item.get('created_at')

            proj.total += 1

            if status in STATUS_DONE:
                proj.done += 1
            elif status in STATUS_ACTIVE:
                proj.active += 1
                if epic:
                    proj.open_epics.add(epic)
            elif status in STATUS_PENDING:
                proj.pending += 1
                if epic:
                    proj.open_epics.add(epic)
                if created:
                    if not proj.oldest_pending_date or created < proj.oldest_pending_date:
                        proj.oldest_pending_date = created
            else:
                proj.abandoned += 1

            if epic:
                proj.epics.add(epic)

        return proj

    def load_detail(self) -> Model:
        if self._detail is None:
            features_path = os.path.join(self.path, BACKLOG_FILE)
            self._detail = Model.load(features_path)
        return self._detail

    @property
    def scope(self) -> int:
        """Active scope: excludes abandoned/superseded."""
        return self.done + self.active + self.pending

    @property
    def percent(self) -> float:
        return (self.done / self.scope * 100) if self.scope else 0

    @property
    def is_complete(self) -> bool:
        return self.pending == 0 and self.active == 0

    @property
    def is_stalled(self) -> bool:
        if self.is_complete:
            return False
        if not self.last_modified:
            return True
        days_since = (datetime.now() - self.last_modified).days
        return days_since >= STALL_DAYS

    @property
    def has_open_work(self) -> bool:
        return self.active > 0 or self.pending > 0


@dataclass
class Portfolio:
    projects: list[ProjectSummary]

    @property
    def total_projects(self) -> int:
        return len(self.projects)

    @property
    def total_features(self) -> int:
        return sum(p.scope for p in self.projects)

    @property
    def total_done(self) -> int:
        return sum(p.done for p in self.projects)

    @property
    def total_active(self) -> int:
        return sum(p.active for p in self.projects)

    @property
    def total_pending(self) -> int:
        return sum(p.pending for p in self.projects)

    @property
    def active_projects(self) -> int:
        return sum(1 for p in self.projects if p.active > 0)

    @property
    def stalled_projects(self) -> int:
        return sum(1 for p in self.projects if p.is_stalled)

    @property
    def complete_projects(self) -> int:
        return sum(1 for p in self.projects if p.is_complete)

    @property
    def archived_projects(self) -> int:
        return sum(1 for p in self.projects if p.archived)

    def sorted_by(self, mode: str) -> list[ProjectSummary]:
        if mode == 'open':
            # Sort by total open work (pending + active), most first
            return sorted(self.projects, key=lambda p: -(p.pending + p.active))
        elif mode == 'modified':
            return sorted(self.projects, key=lambda p: p.last_modified or datetime.min, reverse=True)
        elif mode == 'total':
            return sorted(self.projects, key=lambda p: -p.total)
        elif mode == 'completion':
            return sorted(self.projects, key=lambda p: p.percent)
        return self.projects

    def filtered(self, mode: str = 'open') -> list[ProjectSummary]:
        if mode == 'all':
            return [p for p in self.projects if not p.archived]
        elif mode == 'active':
            return [p for p in self.projects if p.active > 0 and not p.archived]
        elif mode == 'stalled':
            return [p for p in self.projects if p.is_stalled and not p.archived]
        elif mode == 'archived':
            return [p for p in self.projects if p.archived]
        # 'open' - default: has open work AND not archived
        return [p for p in self.projects if p.has_open_work and not p.archived]


def scan_projects(root: str) -> Portfolio:
    projects = []
    root_path = Path(root).expanduser()

    # Directories to skip entirely (never traverse into)
    skip_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv', '.tox',
                 'dist', 'build', '.eggs', '.mypy_cache', '.pytest_cache'}

    for dirpath, dirnames, filenames in os.walk(root_path):
        # Prune directories in-place BEFORE os.walk descends into them
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in skip_dirs]

        if BACKLOG_FILE in filenames:
            features_path = os.path.join(dirpath, BACKLOG_FILE)
            proj = ProjectSummary.from_path(features_path)
            if proj and proj.total > 0:
                projects.append(proj)

    return Portfolio(projects=projects)


# ═══════════════════════════════════════════════════════════════════════════════
# TREE VIEW DATA MODEL
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class TreeNode:
    """Node in collapsible tree hierarchy."""
    type: str  # 'root' | 'project' | 'epic' | 'feature'
    id: str
    label: str
    children: list['TreeNode'] = field(default_factory=list)
    expanded: bool = False
    data: Any = None  # ProjectSummary | Epic | Feature
    parent: 'TreeNode | None' = None
    project_ref: 'ProjectSummary | None' = None

    @property
    def has_children(self) -> bool:
        return len(self.children) > 0 or (self.type == 'epic' and self.data is None)


@dataclass
class TreeState:
    """State for tree view mode."""
    root: TreeNode
    cursor_idx: int = 0
    scroll_offset: int = 0
    show_all: bool = False
    # Search state
    search_mode: bool = False
    search_query: str = ''
    search_matches: list[TreeNode] = field(default_factory=list)
    search_index: int = 0
    # Zoom state
    zoomed_node: TreeNode | None = None


@dataclass
class EditState:
    """State for edit mode in feature view."""
    mode: str = 'navigate'  # 'navigate' | 'edit'
    field_idx: int = 0
    editing_value: str = ''
    pending_changes: dict = field(default_factory=dict)
    confirm_action: str | None = None  # 'quit' | 'delete' | None


@dataclass
class CreationState:
    """State for entity creation flow."""
    entity_type: str  # 'feature' | 'epic'
    epic_context: str | None = None  # parent epic for features
    fields: dict = field(default_factory=dict)  # draft values, NOT in model
    preview_mode: bool = False
    return_view: str = 'epic'  # where to return after creation


def build_tree(portfolio: Portfolio, show_all: bool = False) -> TreeNode:
    """Build tree from portfolio. Epic children loaded lazily on expand."""
    root = TreeNode(type='root', id='root', label='Portfolio')

    for proj in portfolio.projects:
        if not show_all and (proj.is_complete or proj.archived):
            continue

        proj_node = TreeNode(
            type='project',
            id=proj.path,
            label=proj.name,
            data=proj,
            expanded=True,
            parent=root,
            project_ref=proj,
        )

        for epic_name in sorted(proj.epics):
            epic_node = TreeNode(
                type='epic',
                id=f"{proj.path}:{epic_name}",
                label=epic_name,
                data=None,  # Loaded on expand
                expanded=False,
                parent=proj_node,
                project_ref=proj,
            )
            proj_node.children.append(epic_node)

        if proj_node.children or show_all:
            root.children.append(proj_node)

    return root


def expand_epic(node: TreeNode, show_all: bool = False) -> None:
    """Populate epic children on first expansion (lazy load)."""
    if node.type != 'epic' or node.children:
        return

    proj = node.project_ref
    if not proj:
        return

    model = proj.load_detail()
    epic = model.epics.get(node.label)
    if not epic:
        return

    node.data = epic

    for feat in sorted(epic.features, key=lambda f: f.id):
        if not show_all and feat.is_done:
            continue

        feat_node = TreeNode(
            type='feature',
            id=feat.id,
            label=f"{feat.id} {feat.title}",
            data=feat,
            parent=node,
            project_ref=proj,
        )
        node.children.append(feat_node)


def expand_all(node: TreeNode, show_all: bool = False) -> None:
    """Recursively expand node and all descendants."""
    if node.type == 'epic' and not node.children:
        expand_epic(node, show_all)
    node.expanded = True
    for child in node.children:
        expand_all(child, show_all)


def collapse_all(node: TreeNode) -> None:
    """Recursively collapse node and all descendants."""
    node.expanded = False
    for child in node.children:
        collapse_all(child)


def flatten_tree(node: TreeNode, depth: int = 0, zoomed: TreeNode | None = None) -> list[tuple[int, TreeNode]]:
    """Flatten tree to (depth, node) pairs for rendering.
    If zoomed is set, only include that node and its descendants.
    """
    result = []

    # If zoomed, start from zoomed node as if it were root
    if zoomed and node.type == 'root':
        return flatten_tree(zoomed, 0, None)

    if node.type != 'root':
        result.append((depth, node))

    if node.type == 'root' or node.expanded:
        for child in node.children:
            child_depth = depth + 1 if node.type != 'root' else 0
            result.extend(flatten_tree(child, child_depth, None))

    return result


def find_parent_idx(flat: list[tuple[int, TreeNode]], cursor_idx: int) -> int:
    """Find index of parent node in flattened list."""
    if cursor_idx <= 0 or cursor_idx >= len(flat):
        return -1

    current_depth, _ = flat[cursor_idx]

    for i in range(cursor_idx - 1, -1, -1):
        depth, _ = flat[i]
        if depth < current_depth:
            return i

    return -1


def search_tree(node: TreeNode, query: str) -> list[TreeNode]:
    """Find all nodes matching query (case-insensitive)."""
    matches = []
    query_lower = query.lower()

    if node.type != 'root':
        if query_lower in node.label.lower():
            matches.append(node)
        elif node.type == 'feature' and node.data and node.data.description:
            if query_lower in node.data.description.lower():
                matches.append(node)

    for child in node.children:
        matches.extend(search_tree(child, query))

    return matches


def expand_path_to(node: TreeNode, show_all: bool = False) -> None:
    """Expand all ancestors to make node visible."""
    current = node.parent
    while current and current.type != 'root':
        if current.type == 'epic' and not current.children:
            expand_epic(current, show_all)
        current.expanded = True
        current = current.parent


def find_node_idx(flat: list[tuple[int, TreeNode]], target: TreeNode) -> int:
    """Find index of node in flattened list."""
    for i, (_, node) in enumerate(flat):
        if node is target:
            return i
    return -1


# ═══════════════════════════════════════════════════════════════════════════════
# VIEWS
# ═══════════════════════════════════════════════════════════════════════════════

def view_portfolio(portfolio: Portfolio, state: 'State', width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('PORTFOLIO', inner))
    lines.append('')

    pct = (portfolio.total_done / portfolio.total_features * 100) if portfolio.total_features else 0
    bar_width = min(30, inner - 50)
    lines.append(f"  {portfolio.total_projects} projects   {portfolio.total_features} features   "
                 f"{progress_bar(portfolio.total_done, portfolio.total_features, bar_width, active=portfolio.total_active, pending=portfolio.total_pending)}  "
                 f"{portfolio.total_done} done ({pct:.0f}%)")

    status = []
    if portfolio.active_projects:
        status.append(ansi(f"● {portfolio.active_projects} active", COLOR_ACTIVE))
    if portfolio.stalled_projects:
        status.append(ansi(f"○ {portfolio.stalled_projects} stalled", COLOR_STALLED))
    if portfolio.complete_projects:
        status.append(ansi(f"✓ {portfolio.complete_projects} complete", COLOR_HEALTHY))
    if portfolio.archived_projects:
        status.append(ansi(f"⊘ {portfolio.archived_projects} archived", COLOR_MUTED))
    lines.append('  ' + '    '.join(status))

    lines.append('')
    lines.append(section_header('PROJECTS', inner))
    lines.append('')

    filtered = portfolio.filtered(state.filter_mode)
    sorted_projects = portfolio.sorted_by(state.sort_mode)
    display = [p for p in sorted_projects if p in filtered]

    # Scroll: reserve lines for header (~9) + footer (~6) + frame (2)
    visible_projects = max(1, height - 17)
    scroll = state.project_scroll
    if state.project_index < scroll:
        scroll = state.project_index
    elif state.project_index >= scroll + visible_projects:
        scroll = state.project_index - visible_projects + 1
    state.project_scroll = max(0, scroll)

    visible_slice = display[scroll:scroll + visible_projects]

    for i, proj in enumerate(visible_slice):
        actual_idx = i + scroll
        cursor = ansi('▸', COLOR_PROJECT, bold=True) if actual_idx == state.project_index else ' '
        name = truncate(proj.name, 16).ljust(16)
        bar = progress_bar(proj.done, proj.scope, 16, active=proj.active, pending=proj.pending)
        count = f"{proj.done}/{proj.scope}".rjust(7)
        pct_str = f"{proj.percent:3.0f}%"

        if proj.is_complete:
            status_str = ansi('✓ complete', COLOR_HEALTHY)
        elif proj.is_stalled:
            status_str = ansi('○ stalled ', COLOR_STALLED)
        elif proj.active:
            status_str = ansi(f'● {proj.active} active', COLOR_ACTIVE)
        else:
            status_str = ansi(f'○ {proj.pending} pending', COLOR_MUTED)

        if proj.archived:
            status_str = status_str + ansi(' ⊘', COLOR_MUTED)

        if proj.last_modified:
            mod = proj.last_modified.strftime('%b %d')
        else:
            mod = '   -  '
        today_mark = ansi('◆', COLOR_ACTIVE) if proj.worked_today else ' '

        lines.append(f" {cursor}{ansi(name, COLOR_PROJECT)}  {bar}  {count} {pct_str}  {status_str}  {today_mark} {mod}")

    if len(display) > visible_projects:
        lines.append(ansi(f"  ({state.project_index + 1}/{len(display)})", COLOR_MUTED))

    if not display:
        lines.append(f"  {ansi('No projects match current filter', COLOR_MUTED)}")

    # Up next preview for selected project
    if display and 0 <= state.project_index < len(display):
        proj = display[state.project_index]
        if proj.has_open_work:
            model = proj.load_detail()
            upcoming = model.upcoming()
            if upcoming:
                feat = upcoming[0]
                sym = STATUS_SYMBOL.get(feat.status, '?')
                color = STATUS_COLOR.get(feat.status, 0)
                label = 'active:' if feat.is_active else 'up next:'
                title = truncate(feat.title, inner - len(feat.id) - 16)
                lines.append('')
                lines.append(f"  {ansi(label, COLOR_MUTED)} {ansi(feat.id, color)} {ansi(sym, color)} {ansi(title, COLOR_MUTED)}")

    stalled = [p for p in portfolio.projects if p.is_stalled]
    if stalled and state.filter_mode != 'stalled':
        lines.append('')
        lines.append(section_header('ATTENTION', inner))
        lines.append('')
        for proj in stalled[:3]:
            days = (datetime.now() - proj.last_modified).days if proj.last_modified else '?'
            lines.append(f"  {ansi('⚠', COLOR_STALLED)} {proj.name}: stalled {days} days, {proj.pending} pending")

    lines.append('')
    return lines


def view_project(model: Model, state: 'State', width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('PROGRESS', inner))
    lines.append('')

    pct = (model.done / model.total * 100) if model.total else 0
    bar_width = min(50, inner - 20)
    lines.append(f"  {progress_bar(model.done, model.total, bar_width, active=model.active, pending=model.pending, abandoned=model.abandoned)}  {model.done}/{model.total}  {pct:.1f}%")

    status_parts = []
    if model.done:
        status_parts.append(ansi(f"✓ {model.done} done", STATUS_COLOR['done']))
    if model.active:
        status_parts.append(ansi(f"◉ {model.active} active", STATUS_COLOR['in_progress']))
    if model.pending:
        status_parts.append(ansi(f"○ {model.pending} pending", STATUS_COLOR['pending']))
    abandoned = sum(1 for f in model.features.values() if f.status == 'abandoned')
    if abandoned:
        status_parts.append(ansi(f"✗ {abandoned} abandoned", STATUS_COLOR['abandoned']))
    superseded = sum(1 for f in model.features.values() if f.status == 'superseded')
    if superseded:
        status_parts.append(ansi(f"↷ {superseded} superseded", STATUS_COLOR['superseded']))
    lines.append('  ' + '   '.join(status_parts))

    lines.append('')
    lines.append(section_header('EPICS', inner))
    lines.append('')

    for i, (epic_name, epic) in enumerate(model.epics.items()):
        bar_w = 16
        bar = progress_bar(epic.done, epic.total, bar_w, active=epic.active, pending=epic.pending, abandoned=epic.abandoned)
        pct_str = f"{epic.percent:3.0f}%" if epic.total else "  -"
        name = truncate(epic_name, 12).ljust(12)
        count = f"{epic.done}/{epic.total}".rjust(5)

        status_hint = ''
        if epic.active:
            status_hint += ansi(f"  ◉ {epic.active} active", STATUS_COLOR['in_progress'])
        if epic.pending:
            status_hint += ansi(f"  ○ {epic.pending} pending", STATUS_COLOR['pending'])

        cursor = ansi('▸', COLOR_EPIC, bold=True) if i == state.epic_index else ' '
        lines.append(f" {cursor}{ansi(name, COLOR_EPIC)}  {bar}  {count} {pct_str}{status_hint}")

    lines.append('')
    lines.append(section_header('RECENT', inner))
    lines.append('')

    sorted_dates = sorted(model.activity.keys(), reverse=True)[:5]
    max_count = max((len(model.activity[d]) for d in sorted_dates), default=1)

    for date in sorted_dates:
        feature_ids = model.activity[date]
        count = len(feature_ids)
        spark_width = min(14, int(count / max_count * 14)) if max_count else 0
        spark = ansi('█' * spark_width + '░' * (14 - spark_width), 34)

        try:
            dt = datetime.fromisoformat(date)
            date_str = dt.strftime('%b %d')
        except ValueError:
            date_str = date[-5:]

        ids_preview = ', '.join(feature_ids[:3])
        if len(feature_ids) > 3:
            ids_preview += f'... (+{len(feature_ids) - 3})'

        lines.append(f"  {date_str}  {spark}  {ansi(ids_preview, COLOR_MUTED)}")

    lines.append('')
    lines.append(section_header('NEXT UP', inner))
    lines.append('')

    upcoming = model.upcoming()[:3]
    for feat in upcoming:
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        name = truncate(feat.id, 18).ljust(18)
        title = truncate(feat.title, 35).ljust(35)

        unlocks = model.unlocks(feat.id)
        unlock_str = f"→ unlocks: {', '.join(unlocks[:2])}" if unlocks else ''

        lines.append(f"  {ansi(sym, color)} {ansi(name, color)}  {title}  {ansi(unlock_str, COLOR_DEP)}")

    if not upcoming:
        lines.append(f"  {ansi('All features complete!', COLOR_HEALTHY)}")

    lines.append('')
    return lines


def view_epic(model: Model, epic_name: str, state: 'State', width: int, height: int) -> list[str]:
    epic = model.epics.get(epic_name)
    if not epic:
        return [f"  Epic '{epic_name}' not found"]

    lines = []
    inner = width - 4

    lines.append('')
    bar_w = min(50, inner - 30)
    lines.append(f"  {progress_bar(epic.done, epic.total, bar_w, active=epic.active, pending=epic.pending, abandoned=epic.abandoned)}  {epic.done}/{epic.total} completed  {epic.percent:.0f}%")

    lines.append('')
    lines.append(section_header('FEATURES', inner))
    lines.append('')

    sorted_features = sorted(epic.features, key=lambda f: f.id)
    for i, feat in enumerate(sorted_features):
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        fid = truncate(feat.id, 14).ljust(14)
        title = truncate(feat.title, 45)

        deps = ''
        if feat.depends_on:
            dep_short = [d.split('-')[-1] if '-' in d else d for d in feat.depends_on[:2]]
            deps = ansi(f"← {', '.join(dep_short)}", COLOR_DEP)

        cursor = ansi('▸', COLOR_EPIC, bold=True) if i == state.feature_index else ' '
        lines.append(f" {cursor}{ansi(sym, color)} {fid}  {title}  {deps}")

    lines.append('')
    return lines


def view_feature(model: Model, feature_id: str, width: int, height: int) -> list[str]:
    feat = model.features.get(feature_id)
    if not feat:
        return [f"  Feature '{feature_id}' not found"]

    lines = []
    inner = width - 4

    lines.append('')
    sym = STATUS_SYMBOL.get(feat.status, '?')
    color = STATUS_COLOR.get(feat.status, 0)
    lines.append(f"  {ansi(feat.title, bold=True)}")
    lines.append(f"  {ansi(f'{sym} {feat.status}', color)}")

    if feat.description:
        lines.append('')
        lines.append(section_header('DESCRIPTION', inner))
        lines.append('')
        words = feat.description.split()
        line = '  '
        for word in words:
            if len(line) + len(word) + 1 > inner:
                lines.append(line)
                line = '  '
            line += word + ' '
        if line.strip():
            lines.append(line)

    lines.append('')
    lines.append(section_header('METADATA', inner))
    lines.append('')

    if feat.epic:
        lines.append(f"  {'Epic':<12}  {ansi(feat.epic, COLOR_EPIC)}")
    if feat.priority is not None:
        prio_label = {0: 'critical', 1: 'high', 2: 'medium', 3: 'low'}.get(feat.priority, str(feat.priority))
        lines.append(f"  {'Priority':<12}  {feat.priority} ({prio_label})")
    if feat.created_at:
        lines.append(f"  {'Created':<12}  {feat.created_at}")
    if feat.spec_file:
        lines.append(f"  {'Spec':<12}  {ansi(feat.spec_file, COLOR_MUTED)}")

    lines.append('')
    lines.append(section_header('DEPENDENCIES', inner))
    lines.append('')

    if feat.depends_on:
        deps_status = []
        for dep_id in feat.depends_on:
            dep = model.features.get(dep_id)
            if dep:
                s = STATUS_SYMBOL.get(dep.status, '?')
                deps_status.append(f"{dep_id} {ansi(s, STATUS_COLOR.get(dep.status, 0))}")
            else:
                deps_status.append(f"{dep_id} ?")
        lines.append(f"  {'Blocked by:':<12}  {', '.join(deps_status)}")
    else:
        lines.append(f"  {'Blocked by:':<12}  (none)")

    unlocks = model.unlocks(feature_id)
    lines.append(f"  {'Unlocks:':<12}  {', '.join(unlocks) if unlocks else '(none)'}")

    if feat.steps:
        lines.append('')
        lines.append(section_header('STEPS', inner))
        lines.append('')
        for i, step in enumerate(feat.steps, 1):
            lines.append(f"  {i}. {truncate(step, inner - 6)}")

    lines.append('')
    return lines


def view_feature_editable(feat: 'Feature', edit: EditState, width: int) -> list[str]:
    """Render feature view in edit mode with field cursor."""
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(f"  {ansi(feat.title or feat.id, bold=True)}")
    lines.append('')
    lines.append(section_header('EDIT FIELDS', inner))
    lines.append('')

    for i, field in enumerate(EDITABLE_FIELDS):
        is_current = (i == edit.field_idx and edit.mode == 'edit')

        # Get value: pending_changes > current editing > feature attribute
        if is_current:
            value = edit.editing_value
        elif field in edit.pending_changes:
            value = edit.pending_changes[field]
        else:
            value = getattr(feat, field, '') or ''

        if field == 'status':
            # Radio buttons
            options = []
            for opt in STATUS_OPTIONS:
                marker = '◉' if value == opt else '○'
                color = STATUS_COLOR.get(opt, 0)
                styled = ansi(f'{marker} {opt}', color)
                options.append(styled)
            display = '  '.join(options)
        elif field == 'depends_on':
            if isinstance(value, list):
                display = f"[{', '.join(value)}]"
            else:
                display = f"[{value}]"
        else:
            display = f"[{value}]"

        prefix = '▸ ' if is_current else '  '
        label = f"{field}:".ljust(14)
        lines.append(f"{prefix}{ansi(label, COLOR_MUTED)}{display}")

    lines.append('')
    return lines


def view_tree(state: 'State', width: int, height: int) -> list[str]:
    """Render tree view."""
    lines = []
    inner = width - 4

    if not state.tree or not state.tree.root:
        return ['  No tree data']

    flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)

    if not flat:
        lines.append('')
        filter_msg = '(all items filtered)' if not state.tree.show_all else '(no projects)'
        lines.append(f"  {ansi(f'Empty tree {filter_msg}', COLOR_MUTED)}")
        lines.append(f"  {ansi('Press [f] to cycle filters', COLOR_MUTED)}")
        return lines

    # Search mode header
    if state.tree.search_mode:
        search_line = f"  /{state.tree.search_query}█"
        if state.tree.search_matches:
            match_info = f" ({state.tree.search_index + 1}/{len(state.tree.search_matches)})"
            search_line += ansi(match_info, COLOR_MUTED)
        lines.append(search_line)
        lines.append('')

    visible_height = max(1, height - 6)
    if state.tree.search_mode:
        visible_height -= 2
    cursor_idx = state.tree.cursor_idx
    scroll = state.tree.scroll_offset

    # Adjust scroll to keep cursor visible
    if cursor_idx < scroll:
        scroll = cursor_idx
    elif cursor_idx >= scroll + visible_height:
        scroll = cursor_idx - visible_height + 1
    state.tree.scroll_offset = max(0, scroll)

    lines.append('')

    for i, (depth, node) in enumerate(flat[scroll:scroll + visible_height]):
        actual_idx = i + scroll
        is_cursor = (actual_idx == cursor_idx)
        is_match = node in state.tree.search_matches
        line = render_tree_node(depth, node, is_cursor, inner, is_match)
        lines.append(line)

    # Stats footer
    lines.append('')
    proj_count = sum(1 for _, n in flat if n.type == 'project')
    epic_count = sum(1 for _, n in flat if n.type == 'epic')
    feat_count = sum(1 for _, n in flat if n.type == 'feature')
    stats = f'{proj_count} projects, {epic_count} epics, {feat_count} features'
    if state.tree.search_matches and not state.tree.search_mode:
        stats += f' | {len(state.tree.search_matches)} matches'
    lines.append(f"  {ansi(stats, COLOR_MUTED)}")

    return lines


def render_tree_node(depth: int, node: TreeNode, is_cursor: bool, width: int, is_match: bool = False) -> str:
    """Render single tree node line."""
    indent = '  ' * depth

    # Expand/collapse indicator
    if node.has_children:
        arrow = '▼ ' if node.expanded else '► '
    else:
        arrow = '  '

    # Status symbol for features
    if node.type == 'feature':
        feat = node.data
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        prefix = ansi(sym, color) + ' '
    else:
        prefix = ''

    # Label with appropriate color
    if node.type == 'project':
        label = ansi(node.label, COLOR_PROJECT, bold=is_cursor)
    elif node.type == 'epic':
        label = ansi(node.label, COLOR_EPIC, bold=is_cursor)
    else:
        label = node.label

    # Progress bar for project/epic
    progress = ''
    if node.type == 'project':
        proj = node.data
        bar = progress_bar(proj.done, proj.scope, 12, active=proj.active, pending=proj.pending)
        pct = f"{proj.percent:.0f}%"
        progress = f"  {proj.done}/{proj.scope} {bar} {pct}"
    elif node.type == 'epic' and node.data and node.expanded:
        epic = node.data
        bar = progress_bar(epic.done, epic.total, 12, active=epic.active, pending=epic.pending, abandoned=epic.abandoned)
        pct = f"{epic.percent:.0f}%"
        progress = f"  {epic.done}/{epic.total} {bar} {pct}"

    # Dependencies for features
    deps = ''
    if node.type == 'feature' and node.data.depends_on:
        dep_ids = ', '.join(node.data.depends_on[:2])
        if len(node.data.depends_on) > 2:
            dep_ids += '...'
        deps = ansi(f" ← {dep_ids}", COLOR_DEP)

    # Match indicator
    match_marker = ansi('●', 220) + ' ' if is_match else ''

    # Cursor indicator
    cursor = ansi('▸', COLOR_PROJECT, bold=True) if is_cursor else ' '

    return f"{cursor}{indent}{arrow}{match_marker}{prefix}{label}{progress}{deps}"


def view_help(width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('NAVIGATION', inner))
    lines.append('')
    lines.append(f"  {ansi('j', bold=True)} / {ansi('↓', bold=True)}      Move selection down")
    lines.append(f"  {ansi('k', bold=True)} / {ansi('↑', bold=True)}      Move selection up")
    lines.append(f"  {ansi('Enter', bold=True)}      Drill down into selected item")
    lines.append(f"  {ansi('Esc', bold=True)} / {ansi('b', bold=True)}    Go back (quit at top level)")
    lines.append(f"  {ansi('h', bold=True)} / {ansi('?', bold=True)}      Show this help")
    lines.append(f"  {ansi('q', bold=True)}          Quit immediately")
    lines.append('')
    lines.append(section_header('PORTFOLIO CONTROLS', inner))
    lines.append('')
    lines.append(f"  {ansi('s', bold=True)}          Cycle sort mode (open/modified/total/completion)")
    lines.append(f"  {ansi('f', bold=True)}          Cycle filter (open/all/active/stalled/archived)")
    lines.append(f"  {ansi('A', bold=True)}          Toggle archive state of selected project")
    lines.append(f"  {ansi('r', bold=True)}          Refresh data from disk")
    lines.append(f"  {ansi('t', bold=True)}          Switch to tree view")
    lines.append('')
    lines.append(section_header('TREE VIEW', inner))
    lines.append('')
    lines.append(f"  {ansi('←', bold=True)}          Collapse node or move to parent")
    lines.append(f"  {ansi('→', bold=True)}          Expand node or drill into feature")
    lines.append(f"  {ansi('o', bold=True)}          Expand all under cursor")
    lines.append(f"  {ansi('O', bold=True)}          Collapse all")
    lines.append(f"  {ansi('/', bold=True)}          Search, {ansi('^n', bold=True)}/{ansi('^p', bold=True)} next/prev match")
    lines.append(f"  {ansi('z', bold=True)}          Zoom to node")
    lines.append(f"  {ansi('f', bold=True)}          Cycle filter (open/all/active/stalled/archived)")
    lines.append(f"  {ansi('t', bold=True)}          Switch back to table view")
    lines.append('')
    lines.append(section_header('CREATION', inner))
    lines.append('')
    lines.append(f"  {ansi('n', bold=True)}          Create new (context-aware: epic on project, feature on epic)")
    lines.append(f"  {ansi('Tab', bold=True)}        Next field")
    lines.append(f"  {ansi('j/k', bold=True)}        Cycle status options")
    lines.append(f"  {ansi('Esc', bold=True)}        Preview / Confirm")
    lines.append('')
    lines.append(section_header('STATUS SYMBOLS', inner))
    lines.append('')
    lines.append(f"  {ansi('✓', STATUS_COLOR['done'])}  done        {ansi('◉', STATUS_COLOR['in_progress'])}  in progress")
    lines.append(f"  {ansi('○', STATUS_COLOR['pending'])}  pending     {ansi('✗', STATUS_COLOR['abandoned'])}  abandoned")
    lines.append(f"  {ansi('↷', STATUS_COLOR['superseded'])}  superseded  {ansi('◆', COLOR_ACTIVE)}  worked today")
    lines.append('')
    lines.append(section_header('USAGE', inner))
    lines.append('')
    lines.append(f"  {ansi('pv', bold=True)}                   Scan ~/Code, portfolio view")
    lines.append(f"  {ansi('pv /path', bold=True)}             Scan specific directory")
    lines.append(f"  {ansi('pv features.yaml', bold=True)}     Project view for specific file")
    lines.append(f"  {ansi('fv', bold=True)}                   Project view for ./features.yaml")
    lines.append('')

    return lines


def view_creation(state: 'State', width: int) -> list[str]:
    """Render creation view with field editor."""
    lines = []
    inner = width - 4
    cs = state.creation

    if cs.preview_mode:
        return view_creation_preview(state, width)

    entity_label = 'Feature' if cs.entity_type == 'feature' else 'Epic'
    lines.append('')
    lines.append(f"  {ansi(f'New {entity_label}', bold=True)}")
    if cs.entity_type == 'feature':
        lines.append(f"  {ansi(f'Epic: {cs.epic_context}', COLOR_EPIC)}")
    lines.append('')
    lines.append(section_header('FIELDS', inner))
    lines.append('')

    fields = CREATION_FIELDS_FEATURE if cs.entity_type == 'feature' else CREATION_FIELDS_EPIC

    for i, fld in enumerate(fields):
        is_current = (i == state.edit.field_idx)
        value = state.edit.editing_value if is_current else cs.fields.get(fld, '')

        if fld == 'status':
            options = []
            for opt in STATUS_OPTIONS:
                marker = '◉' if value == opt else '○'
                color = STATUS_COLOR.get(opt, 0)
                options.append(ansi(f'{marker} {opt}', color))
            display = '  '.join(options)
        elif fld == 'depends_on':
            if isinstance(value, list):
                display = f"[{', '.join(value)}]"
            else:
                display = f"[{value}]"
        else:
            display = f"[{value}]"

        prefix = '▸ ' if is_current else '  '
        label = f"{fld}:".ljust(14)
        lines.append(f"{prefix}{ansi(label, COLOR_MUTED)}{display}")

    lines.append('')
    return lines


def view_creation_preview(state: 'State', width: int) -> list[str]:
    """Show JSON preview before commit."""
    lines = []
    cs = state.creation

    lines.append('')
    lines.append(f"  {ansi('Review before creating:', bold=True)}")
    lines.append('')

    if cs.entity_type == 'feature':
        preview = op_preview_feature(cs.epic_context, cs.fields)
    else:
        preview = op_preview_epic(cs.fields.get('name', ''))

    for key, val in preview.items():
        if val:
            val_str = json.dumps(val) if isinstance(val, (list, dict)) else str(val)
            lines.append(f"  {ansi(key + ':', COLOR_MUTED)} {val_str}")

    lines.append('')
    lines.append(f"  {ansi('[c] Confirm and create', COLOR_HEALTHY)}")
    lines.append(f"  {ansi('[e] Edit more', COLOR_MUTED)}")
    lines.append(f"  {ansi('[Esc] Cancel', COLOR_MUTED)}")
    lines.append('')
    return lines


# ═══════════════════════════════════════════════════════════════════════════════
# STATE & INPUT
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class State:
    view: str = 'portfolio'

    # Portfolio level
    portfolio: Portfolio | None = None
    scan_root: str | None = None  # For refresh
    project_index: int = 0
    project_scroll: int = 0
    sort_mode: str = 'modified'
    filter_mode: str = 'all'

    # Project level
    current_project: ProjectSummary | None = None
    epic_index: int = 0

    # Epic level
    current_epic: str | None = None
    feature_index: int = 0

    # Feature level
    current_feature: str | None = None

    # Previous view for help overlay
    prev_view: str | None = None

    # Tree view
    tree: TreeState | None = None

    # Edit mode
    edit: EditState | None = None
    dirty: bool = False

    # Creation mode
    creation: CreationState | None = None

    # Flash message (clears on next keypress)
    flash_message: str | None = None


def handle_input(key: str, state: State) -> State | None:
    # Clear flash on any keypress
    state.flash_message = None

    # Handle creation view
    if state.view == 'creation':
        return handle_creation_input(key, state)

    # Handle quit confirmation when dirty
    if state.edit and state.edit.confirm_action == 'quit':
        if key == 's':
            apply_pending_changes(state)
            save_features(state.current_project)
            return None
        elif key == 'd':
            return None
        elif key == 'c':
            state.edit.confirm_action = None
        return state

    if key in ('?', 'h'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
        else:
            state.prev_view = state.view
            state.view = 'help'
        return state

    # Quit
    if key in ('q', '\x03'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
            return state
        # Prompt for unsaved changes
        if state.dirty:
            if not state.edit:
                state.edit = EditState()
            state.edit.confirm_action = 'quit'
            return state
        return None

    # Back navigation (Esc/b/Backspace) - go back one level, quit at top
    if key in ('\x1b', 'b', '\x7f'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
        elif state.view == 'feature':
            # In edit mode, Esc returns to navigate mode (handled by handle_feature_input)
            if state.edit and state.edit.mode == 'edit':
                return handle_feature_input(key, state)
            # In navigate mode, go back
            if state.tree:
                state.view = 'tree'
            else:
                state.view = 'epic'
            state.current_feature = None
            state.edit = None
        elif state.view == 'epic':
            state.view = 'project'
            state.current_epic = None
            state.feature_index = 0
        elif state.view == 'project':
            if state.portfolio:
                state.view = 'portfolio'
                state.current_project = None
                state.epic_index = 0
            else:
                # Direct project mode (fv), no portfolio to go back to → quit
                return None
        elif state.view == 'tree':
            state.view = 'portfolio'
            state.tree = None
        elif state.view == 'portfolio':
            # At top level, Esc quits (natural "escape out" pattern)
            return None
        return state

    # View-specific input handling
    if state.view == 'portfolio':
        return handle_portfolio_input(key, state)
    elif state.view == 'project':
        return handle_project_input(key, state)
    elif state.view == 'epic':
        return handle_epic_input(key, state)
    elif state.view == 'feature':
        return handle_feature_input(key, state)
    elif state.view == 'tree':
        return handle_tree_input(key, state)

    return state


def handle_portfolio_input(key: str, state: State) -> State:
    portfolio = state.portfolio
    if not portfolio:
        return state

    filtered = portfolio.filtered(state.filter_mode)
    sorted_projects = portfolio.sorted_by(state.sort_mode)
    display = [p for p in sorted_projects if p in filtered]

    if key in ('j', 'down'):
        state.project_index = min(state.project_index + 1, len(display) - 1)
    elif key in ('k', 'up'):
        state.project_index = max(state.project_index - 1, 0)
    elif key == 's':
        idx = SORT_MODES.index(state.sort_mode)
        state.sort_mode = SORT_MODES[(idx + 1) % len(SORT_MODES)]
        state.project_index = 0
        state.project_scroll = 0
    elif key == 'f':
        idx = FILTER_MODES.index(state.filter_mode)
        state.filter_mode = FILTER_MODES[(idx + 1) % len(FILTER_MODES)]
        state.project_index = 0
        state.project_scroll = 0
    elif key in ('\r', '\n'):
        if display and 0 <= state.project_index < len(display):
            state.current_project = display[state.project_index]
            state.current_project.load_detail()
            state.view = 'project'
            state.epic_index = 0
    elif key == 't':
        show_all = (state.filter_mode == 'all')
        state.tree = TreeState(
            root=build_tree(state.portfolio, show_all),
            show_all=show_all,
        )
        state.view = 'tree'
    elif key == 'A':
        if display and 0 <= state.project_index < len(display):
            proj = display[state.project_index]
            toggle_archive(proj)
            state.project_index = min(state.project_index, max(0, len(display) - 2))
    elif key == 'r':
        state.portfolio = scan_projects(state.scan_root or '~/Code')
        state.project_index = min(state.project_index, len(portfolio.filtered(state.filter_mode)) - 1)
        state.flash_message = 'Refreshed'

    return state


def handle_project_input(key: str, state: State) -> State:
    if not state.current_project or not state.current_project._detail:
        return state

    model = state.current_project._detail
    epic_names = list(model.epics.keys())

    if key in ('j', 'down'):
        state.epic_index = min(state.epic_index + 1, len(epic_names) - 1)
    elif key in ('k', 'up'):
        state.epic_index = max(state.epic_index - 1, 0)
    elif key in ('\r', '\n'):
        if epic_names and 0 <= state.epic_index < len(epic_names):
            state.current_epic = epic_names[state.epic_index]
            state.view = 'epic'
            state.feature_index = 0
    elif key == 'n':
        state.creation = CreationState(
            entity_type='epic',
            return_view='project',
        )
        state.edit = EditState(mode='edit', field_idx=0)
        state.view = 'creation'
        load_creation_field(state)
    elif key == 'r':
        features_path = os.path.join(state.current_project.path, BACKLOG_FILE)
        state.current_project._detail = Model.load(features_path)
        state.flash_message = 'Refreshed'

    return state


def handle_epic_input(key: str, state: State) -> State:
    if not state.current_project or not state.current_project._detail or not state.current_epic:
        return state

    model = state.current_project._detail
    epic = model.epics.get(state.current_epic)
    if not epic:
        return state

    sorted_features = sorted(epic.features, key=lambda f: f.id)

    if key in ('j', 'down'):
        state.feature_index = min(state.feature_index + 1, len(sorted_features) - 1)
    elif key in ('k', 'up'):
        state.feature_index = max(state.feature_index - 1, 0)
    elif key in ('\r', '\n'):
        if sorted_features and 0 <= state.feature_index < len(sorted_features):
            state.current_feature = sorted_features[state.feature_index].id
            state.view = 'feature'
            state.edit = None  # Reset edit state when entering feature
    elif key == 'n':
        state.creation = CreationState(
            entity_type='feature',
            epic_context=state.current_epic,
            return_view='epic',
        )
        state.edit = EditState(mode='edit', field_idx=0)
        state.view = 'creation'
        load_creation_field(state)
    elif key == 'r':
        features_path = os.path.join(state.current_project.path, BACKLOG_FILE)
        state.current_project._detail = Model.load(features_path)
        state.flash_message = 'Refreshed'

    return state


def next_feature_id(model: 'Model', epic: str) -> str:
    """Generate next ID for epic (e.g., auth-005)."""
    pattern = re.compile(rf'^{re.escape(epic)}-(\d+)$')

    max_num = 0
    for fid in model.features.keys():
        match = pattern.match(fid)
        if match:
            max_num = max(max_num, int(match.group(1)))

    return f"{epic}-{max_num + 1:03d}"


# ═══════════════════════════════════════════════════════════════════════════════
# ENTITY OPERATIONS (AI-agent friendly)
# ═══════════════════════════════════════════════════════════════════════════════

def op_create_feature(model: Model, epic: str, fields: dict = None) -> Feature:
    """Create feature in epic. Adds to model immediately."""
    fields = fields or {}
    new_id = next_feature_id(model, epic)
    today = datetime.now().strftime('%Y-%m-%d')

    feat = Feature(
        id=new_id,
        status=fields.get('status', 'pending'),
        title=fields.get('title', ''),
        description=fields.get('description', ''),
        epic=epic,
        depends_on=fields.get('depends_on', []),
        priority=fields.get('priority'),
        created_at=today,
        notes=fields.get('notes'),
    )

    model.features[new_id] = feat
    if epic not in model.epics:
        model.epics[epic] = Epic(name=epic)
    model.epics[epic].features.append(feat)

    return feat


def op_create_epic(model: Model, name: str) -> Epic:
    """Create new epic. Adds to model immediately."""
    if name in model.epics:
        raise ValueError(f"Epic '{name}' already exists")

    epic = Epic(name=name)
    model.epics[name] = epic
    return epic


def op_preview_feature(epic: str, fields: dict) -> dict:
    """Preview feature as JSON without modifying model. For confirmation UI."""
    return {
        'id': f'{epic}-???',
        'status': fields.get('status', 'pending'),
        'title': fields.get('title', ''),
        'epic': epic,
        'description': fields.get('description', ''),
        'depends_on': fields.get('depends_on', []),
        'priority': fields.get('priority'),
        'created_at': datetime.now().strftime('%Y-%m-%d'),
    }


def op_preview_epic(name: str) -> dict:
    """Preview epic as JSON without modifying model."""
    return {'name': name, 'features': []}


def handle_feature_input(key: str, state: State) -> State:
    """Handle input in feature view (navigate + edit modes)."""
    if not state.current_project or not state.current_project._detail or not state.current_feature:
        return state

    if not state.edit:
        state.edit = EditState()

    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return state

    # Handle confirmation dialogs first
    if state.edit.confirm_action == 'delete':
        if key == 'y':
            model = state.current_project._detail
            feat_id = state.current_feature
            feat_obj = model.features.get(feat_id)
            if feat_obj:
                del model.features[feat_id]
                if feat_obj.epic and feat_obj.epic in model.epics:
                    model.epics[feat_obj.epic].features = [
                        f for f in model.epics[feat_obj.epic].features if f.id != feat_id
                    ]
            state.dirty = True
            state.edit.confirm_action = None
            state.current_feature = None
            state.view = 'epic'
        elif key == 'n':
            state.edit.confirm_action = None
        return state

    # Navigate mode
    if state.edit.mode == 'navigate':
        if key == 'e':
            state.edit.mode = 'edit'
            state.edit.field_idx = 0
            load_field_value(state)
        elif key == 'D':
            state.edit.confirm_action = 'delete'
        elif key == 'w' and state.dirty:
            apply_pending_changes(state)
            if save_features(state.current_project):
                state.dirty = False
                state.edit.pending_changes.clear()
        elif key == 'r' and not state.dirty:
            features_path = os.path.join(state.current_project.path, BACKLOG_FILE)
            state.current_project._detail = Model.load(features_path)
            state.flash_message = 'Refreshed'
        return state

    # Edit mode
    if key == '\x1b':  # Esc - commit current field and exit edit mode
        commit_field_edit(state)
        state.edit.mode = 'navigate'
        state.edit.editing_value = ''
        return state

    if key == '\t':  # Tab - commit and advance
        commit_field_edit(state)
        state.edit.field_idx = (state.edit.field_idx + 1) % len(EDITABLE_FIELDS)
        load_field_value(state)
        return state

    field = EDITABLE_FIELDS[state.edit.field_idx]

    if field == 'status':
        if key in ('j', 'down'):
            current = state.edit.editing_value
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx + 1) % len(STATUS_OPTIONS)]
            state.dirty = True
        elif key in ('k', 'up'):
            current = state.edit.editing_value
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx - 1) % len(STATUS_OPTIONS)]
            state.dirty = True
    else:
        # Text field editing
        if key == '\x7f':  # Backspace
            state.edit.editing_value = state.edit.editing_value[:-1]
            state.dirty = True
        elif len(key) == 1 and key.isprintable():
            state.edit.editing_value += key
            state.dirty = True

    return state


def load_field_value(state: State) -> None:
    """Load current field value into editing_value."""
    if not state.edit or not state.current_project or not state.current_feature:
        return

    field = EDITABLE_FIELDS[state.edit.field_idx]
    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return

    if field in state.edit.pending_changes:
        value = state.edit.pending_changes[field]
    else:
        value = getattr(feat, field, '') or ''

    if field == 'depends_on' and isinstance(value, list):
        value = ', '.join(value)

    state.edit.editing_value = str(value) if value else ''


def commit_field_edit(state: State) -> None:
    """Store current editing_value in pending_changes."""
    if not state.edit:
        return

    field = EDITABLE_FIELDS[state.edit.field_idx]
    value = state.edit.editing_value

    if field == 'depends_on':
        value = [x.strip() for x in value.split(',') if x.strip()]
    elif field == 'priority':
        try:
            value = int(value) if value else None
        except ValueError:
            value = None

    state.edit.pending_changes[field] = value


def load_creation_field(state: State) -> None:
    """Load current field value into editing_value for creation mode."""
    cs = state.creation
    if not cs or not state.edit:
        return

    fields = CREATION_FIELDS_FEATURE if cs.entity_type == 'feature' else CREATION_FIELDS_EPIC
    fld = fields[state.edit.field_idx]

    value = cs.fields.get(fld, '')

    # Default status to 'pending' for new features
    if fld == 'status' and not value:
        value = 'pending'

    if fld == 'depends_on' and isinstance(value, list):
        value = ', '.join(value)

    state.edit.editing_value = str(value) if value else ''


def commit_creation_field(state: State) -> None:
    """Store current editing_value in creation fields dict."""
    cs = state.creation
    if not cs or not state.edit:
        return

    fields = CREATION_FIELDS_FEATURE if cs.entity_type == 'feature' else CREATION_FIELDS_EPIC
    fld = fields[state.edit.field_idx]
    value = state.edit.editing_value

    if fld == 'depends_on':
        value = [x.strip() for x in value.split(',') if x.strip()]
    elif fld == 'priority':
        try:
            value = int(value) if value else None
        except ValueError:
            value = None

    cs.fields[fld] = value


def apply_pending_changes(state: State) -> None:
    """Apply pending edits to Feature object."""
    if not state.edit:
        return

    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return

    # Only commit current field if we're still in edit mode
    if state.edit.mode == 'edit':
        commit_field_edit(state)

    # Apply all pending changes to feature
    for field, value in state.edit.pending_changes.items():
        setattr(feat, field, value)

    state.edit.pending_changes.clear()


def save_features(project: 'ProjectSummary') -> bool:
    """Save features.yaml. Returns True on success."""
    features_path = os.path.join(project.path, BACKLOG_FILE)
    model = project._detail
    if not model:
        return False

    data = []
    for feat in model.features.values():
        item = {'id': feat.id, 'status': feat.status}
        for attr in ['title', 'description', 'epic', 'depends_on', 'priority',
                     'created_at', 'spec_file', 'steps', 'discovered_from', 'notes']:
            val = getattr(feat, attr, None)
            if val is not None:
                item[attr] = val
        data.append(item)

    data.sort(key=lambda x: x['id'])

    with open(features_path, 'w') as f:
        yaml.dump(data, f, default_flow_style=False, sort_keys=False)

    return True


def toggle_archive(project: ProjectSummary) -> bool:
    """Toggle project archive state. Returns new archived state."""
    marker = os.path.join(project.path, '.archived')
    if project.archived:
        os.remove(marker)
        project.archived = False
    else:
        Path(marker).touch()
        project.archived = True
    return project.archived


def handle_tree_input(key: str, state: State) -> State:
    """Handle input in tree view."""
    if not state.tree:
        return state

    # Handle search mode input
    if state.tree.search_mode:
        return handle_tree_search_input(key, state)

    flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)

    # Handle empty tree
    if not flat:
        if key == 't':
            state.view = 'portfolio'
        elif key == 'f':
            idx = FILTER_MODES.index(state.filter_mode)
            state.filter_mode = FILTER_MODES[(idx + 1) % len(FILTER_MODES)]
            state.tree.show_all = (state.filter_mode != 'open')
            state.tree.root = build_tree(state.portfolio, state.tree.show_all)
            state.tree.cursor_idx = 0
        elif key == '/':
            state.tree.search_mode = True
            state.tree.search_query = ''
        return state

    # Clamp cursor to valid range
    cursor_idx = min(state.tree.cursor_idx, len(flat) - 1)
    cursor_idx = max(0, cursor_idx)
    state.tree.cursor_idx = cursor_idx

    if key in ('j', 'down'):
        if cursor_idx < len(flat) - 1:
            state.tree.cursor_idx = cursor_idx + 1

    elif key in ('k', 'up'):
        if cursor_idx > 0:
            state.tree.cursor_idx = cursor_idx - 1

    elif key in ('right', '\r', '\n'):
        _, node = flat[cursor_idx]
        if node.type == 'epic' and not node.expanded:
            expand_epic(node, state.tree.show_all)
            node.expanded = True
        elif node.has_children and not node.expanded:
            node.expanded = True
        elif node.type == 'feature':
            proj = node.project_ref
            if proj:
                proj.load_detail()
                state.current_project = proj
                state.current_epic = node.parent.label if node.parent else None
                state.current_feature = node.data.id
                state.view = 'feature'

    elif key == 'left':
        _, node = flat[cursor_idx]
        if node.expanded:
            node.expanded = False
        else:
            parent_idx = find_parent_idx(flat, cursor_idx)
            if parent_idx >= 0:
                state.tree.cursor_idx = parent_idx

    elif key == 'o':
        _, node = flat[cursor_idx]
        expand_all(node, state.tree.show_all)

    elif key == 'O':
        collapse_all(state.tree.root)
        state.tree.cursor_idx = 0
        state.tree.search_matches = []

    elif key == 't':
        state.view = 'portfolio'

    elif key == 'f':
        idx = FILTER_MODES.index(state.filter_mode)
        state.filter_mode = FILTER_MODES[(idx + 1) % len(FILTER_MODES)]
        state.tree.show_all = (state.filter_mode != 'open')
        state.tree.root = build_tree(state.portfolio, state.tree.show_all)
        state.tree.cursor_idx = 0
        state.tree.search_matches = []

    elif key == 'A':
        _, node = flat[cursor_idx]
        if node.type == 'project' and node.data:
            toggle_archive(node.data)
            state.tree.root = build_tree(state.portfolio, state.tree.show_all)
            state.tree.cursor_idx = min(cursor_idx, len(flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)) - 1)

    elif key == '/':
        state.tree.search_mode = True
        state.tree.search_query = ''
        state.tree.search_matches = []
        state.tree.search_index = 0

    elif key == 'n' and not state.tree.search_matches:
        # Create new entity (only when not navigating search matches)
        _, node = flat[cursor_idx]
        if node.type == 'project':
            proj = node.project_ref
            proj.load_detail()
            state.current_project = proj
            state.creation = CreationState(
                entity_type='epic',
                return_view='tree',
            )
            state.edit = EditState(mode='edit', field_idx=0)
            state.view = 'creation'
            load_creation_field(state)
        elif node.type == 'epic':
            proj = node.project_ref
            proj.load_detail()
            state.current_project = proj
            state.creation = CreationState(
                entity_type='feature',
                epic_context=node.label,
                return_view='tree',
            )
            state.edit = EditState(mode='edit', field_idx=0)
            state.view = 'creation'
            load_creation_field(state)

    elif key == '\x0e' and state.tree.search_matches:  # Ctrl+n: next match
        state.tree.search_index = (state.tree.search_index + 1) % len(state.tree.search_matches)
        target = state.tree.search_matches[state.tree.search_index]
        expand_path_to(target, state.tree.show_all)
        flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
        idx = find_node_idx(flat, target)
        if idx >= 0:
            state.tree.cursor_idx = idx

    elif key == '\x10' and state.tree.search_matches:  # Ctrl+p: prev match
        state.tree.search_index = (state.tree.search_index - 1) % len(state.tree.search_matches)
        target = state.tree.search_matches[state.tree.search_index]
        expand_path_to(target, state.tree.show_all)
        flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
        idx = find_node_idx(flat, target)
        if idx >= 0:
            state.tree.cursor_idx = idx

    elif key == 'z':
        # Toggle zoom
        _, node = flat[cursor_idx]
        if state.tree.zoomed_node == node:
            state.tree.zoomed_node = None  # Unzoom
        else:
            state.tree.zoomed_node = node  # Zoom to cursor
        state.tree.cursor_idx = 0

    elif key == 'r':
        state.portfolio = scan_projects(state.scan_root or '~/Code')
        state.tree.root = build_tree(state.portfolio, state.tree.show_all)
        state.tree.cursor_idx = 0
        state.tree.zoomed_node = None
        state.tree.search_matches = []
        state.flash_message = 'Refreshed'

    return state


def handle_tree_search_input(key: str, state: State) -> State:
    """Handle input during search mode."""
    ts = state.tree

    if key == '\x1b':  # Escape - cancel search
        ts.search_mode = False
        ts.search_query = ''
        ts.search_matches = []
    elif key in ('\r', '\n'):  # Enter - confirm search, jump to first match
        ts.search_mode = False
        if ts.search_matches:
            target = ts.search_matches[ts.search_index]
            expand_path_to(target, ts.show_all)
            flat = flatten_tree(ts.root, zoomed=ts.zoomed_node)
            idx = find_node_idx(flat, target)
            if idx >= 0:
                ts.cursor_idx = idx
    elif key == '\x7f':  # Backspace
        ts.search_query = ts.search_query[:-1]
        if ts.search_query:
            ts.search_matches = search_tree(ts.root, ts.search_query)
        else:
            ts.search_matches = []
        ts.search_index = 0
    elif len(key) == 1 and key.isprintable():
        ts.search_query += key
        ts.search_matches = search_tree(ts.root, ts.search_query)
        ts.search_index = 0
        # Auto-expand to first match
        if ts.search_matches:
            expand_path_to(ts.search_matches[0], ts.show_all)

    return state


def handle_creation_input(key: str, state: State) -> State:
    """Handle input in creation view."""
    cs = state.creation

    # Preview mode
    if cs.preview_mode:
        if key == 'c':
            commit_creation(state)
            return state
        elif key == 'e':
            cs.preview_mode = False
            state.edit.field_idx = 0
            load_creation_field(state)
            return state
        elif key == '\x1b':
            state.creation = None
            state.edit = None
            state.view = cs.return_view
            return state
        return state

    # Edit mode
    if key == '\x1b':
        commit_creation_field(state)
        cs.preview_mode = True
        return state

    if key == '\t':
        commit_creation_field(state)
        fields = CREATION_FIELDS_FEATURE if cs.entity_type == 'feature' else CREATION_FIELDS_EPIC
        state.edit.field_idx = (state.edit.field_idx + 1) % len(fields)
        load_creation_field(state)
        return state

    fields = CREATION_FIELDS_FEATURE if cs.entity_type == 'feature' else CREATION_FIELDS_EPIC
    fld = fields[state.edit.field_idx]

    if fld == 'status':
        if key in ('j', 'down'):
            current = state.edit.editing_value or 'pending'
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx + 1) % len(STATUS_OPTIONS)]
        elif key in ('k', 'up'):
            current = state.edit.editing_value or 'pending'
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx - 1) % len(STATUS_OPTIONS)]
    else:
        if key == '\x7f':
            state.edit.editing_value = state.edit.editing_value[:-1]
        elif len(key) == 1 and key.isprintable():
            state.edit.editing_value += key

    return state


def commit_creation(state: State) -> None:
    """Commit creation to model and save."""
    cs = state.creation
    model = state.current_project._detail

    if cs.entity_type == 'feature':
        feat = op_create_feature(model, cs.epic_context, cs.fields)
        state.current_feature = feat.id
        state.flash_message = f"Created {feat.id}"
        state.view = 'feature'
        state.edit = None
    else:
        epic = op_create_epic(model, cs.fields.get('name', ''))
        state.flash_message = f"Created epic: {epic.name}"
        state.view = cs.return_view
        state.edit = None

    save_features(state.current_project)
    state.creation = None


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

def render(state: State, width: int, height: int) -> str:
    if state.view == 'creation':
        cs = state.creation
        title = f"new {cs.entity_type}"
        if cs.preview_mode:
            footer = '[c]onfirm [e]dit [Esc]cancel'
        else:
            footer = '[Tab]next [j/k]status [Esc]preview'
        lines = view_creation(state, width)
    elif state.view == 'help':
        title = 'help'
        footer = '[Esc]back'
        lines = view_help(width, height)
    elif state.view == 'tree':
        title = 'tree'
        hints = []
        if state.tree and state.tree.show_all:
            hints.append('[all]')
        if state.tree and state.tree.zoomed_node:
            hints.append('[zoomed]')
        hint_str = ' ' + ' '.join(hints) if hints else ''
        if state.tree and state.tree.search_mode:
            footer = '[Enter]confirm [Esc]cancel'
        elif state.tree and state.tree.search_matches:
            footer = f'[^n/^p]nav [/]search [r]efresh [z]oom [t]able [h]elp [q]uit{hint_str}'
        else:
            footer = f'[/]search [r]efresh [f]ilter:{state.filter_mode} [t]able [h]elp [q]uit{hint_str}'
        lines = view_tree(state, width, height)
    elif state.view == 'portfolio':
        title = 'pv'
        footer = f'[s]ort:{state.sort_mode} [f]ilter:{state.filter_mode} [r]efresh [t]ree [h]elp [q]uit'
        lines = view_portfolio(state.portfolio, state, width, height)
    elif state.view == 'project':
        proj_name = state.current_project.name if state.current_project else 'project'
        title = proj_name
        footer = '[n]ew epic [r]efresh [Esc]back [h]elp [q]uit'
        model = state.current_project._detail if state.current_project else None
        if model:
            lines = view_project(model, state, width, height)
        else:
            lines = ['  No project loaded']
    elif state.view == 'epic':
        title = f'epic: {state.current_epic}'
        footer = '[n]ew [r]efresh [Esc]back [h]elp [q]uit'
        model = state.current_project._detail if state.current_project else None
        if model and state.current_epic:
            lines = view_epic(model, state.current_epic, state, width, height)
        else:
            lines = ['  No epic selected']
    elif state.view == 'feature':
        title = state.current_feature or 'feature'
        model = state.current_project._detail if state.current_project else None

        # Build footer based on edit state
        if state.edit and state.edit.confirm_action == 'delete':
            footer = f"Delete {state.current_feature}? [y]es [n]o"
        elif state.edit and state.edit.confirm_action == 'quit':
            footer = "Unsaved changes. [s]ave [d]iscard [c]ancel"
        elif state.edit and state.edit.mode == 'edit':
            footer = "[Tab]next [j/k]status [Esc]exit"
        else:
            dirty_hint = " [w]rite" if state.dirty else ""
            footer = f"[e]dit [D]elete{dirty_hint} [Esc]back [q]uit"

        if state.dirty:
            footer = "[*] " + footer

        if model and state.current_feature:
            feat = model.features.get(state.current_feature)
            if feat and state.edit and state.edit.mode == 'edit':
                lines = view_feature_editable(feat, state.edit, width)
            else:
                lines = view_feature(model, state.current_feature, width, height)
        else:
            lines = ['  No feature selected']
    else:
        lines = ['  Unknown view']
        title = ''
        footer = ''

    # Prepend flash message to footer
    if state.flash_message:
        footer = f"✓ {state.flash_message}  │  {footer}"

    framed = frame(lines, width, title, footer)
    return '\n'.join(framed)


def init_portfolio_state(root: str) -> State:
    portfolio = scan_projects(root)
    return State(view='portfolio', portfolio=portfolio, scan_root=root)


def init_project_state(features_path: str) -> State:
    model = Model.load(features_path)
    proj = ProjectSummary.from_path(features_path)
    if proj:
        proj._detail = model
    else:
        proj = ProjectSummary(path=str(Path(features_path).parent), name=Path(features_path).parent.name)
        proj._detail = model
    return State(
        view='project',
        portfolio=None,
        current_project=proj,
    )


def detect_entry_point() -> State:
    prog_name = os.path.basename(sys.argv[0])
    is_fv_mode = prog_name in ('fv', 'fv.py')

    if len(sys.argv) < 2:
        if is_fv_mode:
            if os.path.exists(BACKLOG_FILE):
                return init_project_state(BACKLOG_FILE)
            else:
                print(f"Error: {BACKLOG_FILE} not found")
                print(f"Run from a directory containing {BACKLOG_FILE}, or specify path.")
                sys.exit(1)
        else:
            return init_portfolio_state('~/Code')

    arg = sys.argv[1]

    if arg in ('-h', '--help'):
        print(__doc__)
        sys.exit(0)

    if arg.endswith(('.yaml', '.yml', '.json')):
        if not os.path.exists(arg):
            print(f"Error: {arg} not found")
            sys.exit(1)
        return init_project_state(arg)

    if os.path.isdir(arg):
        return init_portfolio_state(arg)

    print(f"Error: {arg} not found")
    sys.exit(1)


def main():
    try:
        state = detect_entry_point()
    except yaml.YAMLError as e:
        print(f"Error parsing YAML: {e}")
        sys.exit(1)
    except KeyError as e:
        print(f"Error: missing required field {e}")
        sys.exit(1)

    size = get_terminal_size()

    # Non-interactive mode
    if not sys.stdin.isatty():
        output = render(state, size.columns, size.lines)
        print(output)
        return

    # Clear screen and hide cursor
    print('\033[2J\033[H\033[?25l', end='')

    try:
        while True:
            size = get_terminal_size()
            output = render(state, size.columns, size.lines)
            print(f'\033[H{output}\033[J', end='', flush=True)

            key = getch()
            state = handle_input(key, state)
            if state is None:
                break
    finally:
        print('\033[?25h\033[2J\033[H', end='')


if __name__ == '__main__':
    main()
