#!/usr/bin/env python3
"""
pv - Portfolio & Feature Viewer

Unified TUI for features.json tracking.
Navigate: Portfolio → Project → Epic → Feature

Usage:
    pv                    # Scan ~/Code, portfolio view
    pv /path              # Scan specific directory
    pv features.json      # Project view for specific file
    fv                    # Alias: project view for ./features.json

Navigation:
    j/k or ↑/↓  Move selection
    Enter       Drill down (project/epic/feature)
    b/Esc       Go back
    s           Cycle sort mode (portfolio)
    a           Toggle show all (portfolio)
    z           Show stalled only (portfolio)
    h/?         Show help
    q           Quit
"""

from __future__ import annotations

import json
import os
import re
import sys
import tty
import termios
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from shutil import get_terminal_size
from typing import Any


# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

ANSI_ESCAPE = re.compile(r'\033\[[0-9;]*m')

STATUS_DONE = {'done', 'complete'}
STATUS_ACTIVE = {'in_progress'}
STATUS_PENDING = {'pending'}

STATUS_SYMBOL = {
    'done': '✓', 'complete': '✓',
    'in_progress': '◉',
    'pending': '○',
    'abandoned': '✗',
    'superseded': '↷',
}

STATUS_COLOR = {
    'done': 34, 'complete': 34,
    'in_progress': 33,
    'pending': 245,
    'abandoned': 238,
    'superseded': 238,
}

COLOR_MUTED = 240
COLOR_EPIC = 39
COLOR_PROJECT = 39
COLOR_DEP = 213
COLOR_HEALTHY = 34
COLOR_ACTIVE = 33
COLOR_STALLED = 131
COLOR_BORDER = 237

BOX = {
    'tl': '┌', 'tr': '┐', 'bl': '└', 'br': '┘',
    'h': '─', 'v': '│', 'title': '═',
}

BLOCKS = ' ▏▎▍▌▋▊▉█'
SORT_MODES = ['open', 'modified', 'total', 'completion']
STALL_DAYS = 14

# Edit mode
EDITABLE_FIELDS = ['title', 'status', 'priority', 'description', 'depends_on', 'notes']
STATUS_OPTIONS = ['pending', 'in_progress', 'done', 'abandoned', 'superseded']


# ═══════════════════════════════════════════════════════════════════════════════
# ANSI RENDERING
# ═══════════════════════════════════════════════════════════════════════════════

def ansi(text: str, color: int | None = None, bold: bool = False, dim: bool = False) -> str:
    if not (color or bold or dim):
        return text
    codes = []
    if bold:
        codes.append('1')
    if dim:
        codes.append('2')
    if color:
        codes.append(f'38;5;{color}')
    return f"\033[{';'.join(codes)}m{text}\033[0m"


def visible_len(text: str) -> int:
    return len(ANSI_ESCAPE.sub('', text))


def progress_bar(done: int, total: int, width: int = 40) -> str:
    if total == 0:
        return ansi('░' * width, COLOR_MUTED)

    ratio = done / total
    filled_full = int(ratio * width)
    remainder = (ratio * width) - filled_full
    partial_idx = int(remainder * 8)

    filled_chars = filled_full
    bar = '█' * filled_full
    if filled_full < width and partial_idx > 0:
        bar += BLOCKS[partial_idx]
        filled_chars += 1
    bar += '░' * (width - filled_chars)

    done_part = ansi(bar[:filled_chars], COLOR_HEALTHY)
    remaining = ansi(bar[filled_chars:], COLOR_MUTED)
    return done_part + remaining


def truncate(text: str, width: int) -> str:
    if len(text) <= width:
        return text
    return text[:width - 1] + '…'


def frame(lines: list[str], width: int, title: str = '', footer: str = '') -> list[str]:
    inner_width = width - 2
    result = []

    if title:
        title_str = f' {title} '
        pad_left = 2
        pad_right = max(0, inner_width - len(title_str) - pad_left)
        top = BOX['tl'] + BOX['h'] * pad_left + title_str + BOX['h'] * pad_right + BOX['tr']
    else:
        top = BOX['tl'] + BOX['h'] * inner_width + BOX['tr']
    result.append(ansi(top, COLOR_BORDER))

    for line in lines:
        vlen = visible_len(line)
        padding = max(0, inner_width - vlen)
        result.append(ansi(BOX['v'], COLOR_BORDER) + line + ' ' * padding + ansi(BOX['v'], COLOR_BORDER))

    if footer:
        footer_str = f' {footer} '
        pad_right = 2
        pad_left = max(0, inner_width - len(footer_str) - pad_right)
        bottom = BOX['bl'] + BOX['h'] * pad_left + footer_str + BOX['h'] * pad_right + BOX['br']
    else:
        bottom = BOX['bl'] + BOX['h'] * inner_width + BOX['br']
    result.append(ansi(bottom, COLOR_BORDER))

    return result


def section_header(title: str, width: int) -> str:
    line_len = max(0, width - len(title) - 4)
    return f"  {ansi(title, bold=True)} {ansi(BOX['title'] * line_len, COLOR_MUTED)}"


def getch() -> str:
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
        if not ch:
            return 'q'
        if ch == '\x1b':
            ch2 = sys.stdin.read(1)
            if not ch2:
                return ch
            if ch2 == '[':
                ch3 = sys.stdin.read(1)
                if not ch3:
                    return ch
                return {'A': 'up', 'B': 'down', 'C': 'right', 'D': 'left'}.get(ch3, ch)
        return ch
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)


# ═══════════════════════════════════════════════════════════════════════════════
# DATA MODEL - FEATURES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class Feature:
    id: str
    status: str
    title: str = ''
    description: str = ''
    epic: str | None = None
    depends_on: list[str] = field(default_factory=list)
    priority: int | None = None
    created_at: str | None = None
    spec_file: str | None = None
    steps: list[str] = field(default_factory=list)
    discovered_from: str | None = None
    notes: str | None = None

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Feature:
        title = d.get('title') or d.get('name') or d.get('description', '')[:60] or d['id']
        priority = d.get('priority')
        if isinstance(priority, str):
            priority = {'low': 3, 'medium': 2, 'high': 1, 'critical': 0}.get(priority.lower())

        return cls(
            id=d['id'],
            status=d.get('status', 'pending'),
            title=title,
            description=d.get('description', ''),
            epic=d.get('epic'),
            depends_on=d.get('depends_on', []),
            priority=priority,
            created_at=d.get('created_at'),
            spec_file=d.get('spec_file'),
            steps=d.get('steps', []),
            discovered_from=d.get('discovered_from'),
            notes=d.get('notes'),
        )

    @property
    def is_done(self) -> bool:
        return self.status in STATUS_DONE

    @property
    def is_active(self) -> bool:
        return self.status in STATUS_ACTIVE

    @property
    def is_pending(self) -> bool:
        return self.status in STATUS_PENDING


@dataclass
class Epic:
    name: str
    features: list[Feature] = field(default_factory=list)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features if f.is_pending)

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def percent(self) -> float:
        return (self.done / self.total * 100) if self.total else 0


@dataclass
class Model:
    features: dict[str, Feature]
    epics: dict[str, Epic]
    activity: dict[str, list[str]]

    @classmethod
    def load(cls, path: str) -> Model:
        with open(path) as f:
            data = json.load(f)

        features = {}
        epics: dict[str, Epic] = {}
        activity: dict[str, list[str]] = {}

        for item in data:
            feat = Feature.from_dict(item)
            features[feat.id] = feat

            epic_name = feat.epic or '(no epic)'
            if epic_name not in epics:
                epics[epic_name] = Epic(name=epic_name)
            epics[epic_name].features.append(feat)

            if feat.created_at:
                if feat.created_at not in activity:
                    activity[feat.created_at] = []
                activity[feat.created_at].append(feat.id)

        epics = dict(sorted(epics.items(), key=lambda x: (-x[1].percent, x[0])))
        return cls(features=features, epics=epics, activity=activity)

    @property
    def total(self) -> int:
        return len(self.features)

    @property
    def done(self) -> int:
        return sum(1 for f in self.features.values() if f.is_done)

    @property
    def active(self) -> int:
        return sum(1 for f in self.features.values() if f.is_active)

    @property
    def pending(self) -> int:
        return sum(1 for f in self.features.values() if f.is_pending)

    def upcoming(self) -> list[Feature]:
        upcoming = [f for f in self.features.values() if f.is_active or f.is_pending]
        return sorted(upcoming, key=lambda f: (
            0 if f.is_active else 1,
            f.priority if f.priority is not None else 999,
            f.created_at or '9999',
        ))

    def unlocks(self, feature_id: str) -> list[str]:
        return [f.id for f in self.features.values() if feature_id in f.depends_on]


# ═══════════════════════════════════════════════════════════════════════════════
# DATA MODEL - PORTFOLIO
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class ProjectSummary:
    path: str
    name: str
    total: int = 0
    done: int = 0
    active: int = 0
    pending: int = 0
    abandoned: int = 0
    epics: set = field(default_factory=set)
    open_epics: set = field(default_factory=set)
    last_modified: datetime | None = None
    oldest_pending_date: str | None = None
    worked_today: bool = False
    _detail: Model | None = field(default=None, repr=False)

    @classmethod
    def from_path(cls, features_path: str) -> ProjectSummary | None:
        try:
            with open(features_path) as f:
                data = json.load(f)
        except (json.JSONDecodeError, IOError):
            return None

        if not isinstance(data, list):
            return None

        path = Path(features_path).parent
        code_root = Path.home() / 'Code'
        try:
            name = str(path.relative_to(code_root))
        except ValueError:
            name = path.name

        proj = cls(path=str(path), name=name)
        proj.last_modified = datetime.fromtimestamp(os.path.getmtime(features_path))
        proj.worked_today = proj.last_modified.date() == datetime.now().date()

        for item in data:
            status = item.get('status', 'pending')
            epic = item.get('epic')
            created = item.get('created_at')

            proj.total += 1

            if status in STATUS_DONE:
                proj.done += 1
            elif status in STATUS_ACTIVE:
                proj.active += 1
                if epic:
                    proj.open_epics.add(epic)
            elif status in STATUS_PENDING:
                proj.pending += 1
                if epic:
                    proj.open_epics.add(epic)
                if created:
                    if not proj.oldest_pending_date or created < proj.oldest_pending_date:
                        proj.oldest_pending_date = created
            else:
                proj.abandoned += 1

            if epic:
                proj.epics.add(epic)

        return proj

    def load_detail(self) -> Model:
        if self._detail is None:
            features_path = os.path.join(self.path, 'features.json')
            self._detail = Model.load(features_path)
        return self._detail

    @property
    def percent(self) -> float:
        return (self.done / self.total * 100) if self.total else 0

    @property
    def is_complete(self) -> bool:
        return self.pending == 0 and self.active == 0

    @property
    def is_stalled(self) -> bool:
        if self.is_complete:
            return False
        if not self.last_modified:
            return True
        days_since = (datetime.now() - self.last_modified).days
        return days_since >= STALL_DAYS

    @property
    def has_open_work(self) -> bool:
        return self.active > 0 or self.pending > 0


@dataclass
class Portfolio:
    projects: list[ProjectSummary]

    @property
    def total_projects(self) -> int:
        return len(self.projects)

    @property
    def total_features(self) -> int:
        return sum(p.total for p in self.projects)

    @property
    def total_done(self) -> int:
        return sum(p.done for p in self.projects)

    @property
    def active_projects(self) -> int:
        return sum(1 for p in self.projects if p.active > 0)

    @property
    def stalled_projects(self) -> int:
        return sum(1 for p in self.projects if p.is_stalled)

    @property
    def complete_projects(self) -> int:
        return sum(1 for p in self.projects if p.is_complete)

    def sorted_by(self, mode: str) -> list[ProjectSummary]:
        if mode == 'open':
            # Sort by total open work (pending + active), most first
            return sorted(self.projects, key=lambda p: -(p.pending + p.active))
        elif mode == 'modified':
            return sorted(self.projects, key=lambda p: p.last_modified or datetime.min, reverse=True)
        elif mode == 'total':
            return sorted(self.projects, key=lambda p: -p.total)
        elif mode == 'completion':
            return sorted(self.projects, key=lambda p: p.percent)
        return self.projects

    def filtered(self, show_all: bool = False, stalled_only: bool = False) -> list[ProjectSummary]:
        if stalled_only:
            return [p for p in self.projects if p.is_stalled]
        if show_all:
            return self.projects
        return [p for p in self.projects if p.has_open_work]


def scan_projects(root: str) -> Portfolio:
    projects = []
    root_path = Path(root).expanduser()

    # Directories to skip entirely (never traverse into)
    skip_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv', '.tox',
                 'dist', 'build', '.eggs', '.mypy_cache', '.pytest_cache'}

    for dirpath, dirnames, filenames in os.walk(root_path):
        # Prune directories in-place BEFORE os.walk descends into them
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and d not in skip_dirs]

        if 'features.json' in filenames:
            features_path = os.path.join(dirpath, 'features.json')
            proj = ProjectSummary.from_path(features_path)
            if proj and proj.total > 0:
                projects.append(proj)

    return Portfolio(projects=projects)


# ═══════════════════════════════════════════════════════════════════════════════
# TREE VIEW DATA MODEL
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class TreeNode:
    """Node in collapsible tree hierarchy."""
    type: str  # 'root' | 'project' | 'epic' | 'feature'
    id: str
    label: str
    children: list['TreeNode'] = field(default_factory=list)
    expanded: bool = False
    data: Any = None  # ProjectSummary | Epic | Feature
    parent: 'TreeNode | None' = None
    project_ref: 'ProjectSummary | None' = None

    @property
    def has_children(self) -> bool:
        return len(self.children) > 0 or (self.type == 'epic' and self.data is None)


@dataclass
class TreeState:
    """State for tree view mode."""
    root: TreeNode
    cursor_idx: int = 0
    scroll_offset: int = 0
    show_all: bool = False
    # Search state
    search_mode: bool = False
    search_query: str = ''
    search_matches: list[TreeNode] = field(default_factory=list)
    search_index: int = 0
    # Zoom state
    zoomed_node: TreeNode | None = None


@dataclass
class EditState:
    """State for edit mode in feature view."""
    mode: str = 'navigate'  # 'navigate' | 'edit'
    field_idx: int = 0
    editing_value: str = ''
    pending_changes: dict = field(default_factory=dict)
    confirm_action: str | None = None  # 'quit' | 'delete' | None


def build_tree(portfolio: Portfolio, show_all: bool = False) -> TreeNode:
    """Build tree from portfolio. Epic children loaded lazily on expand."""
    root = TreeNode(type='root', id='root', label='Portfolio')

    for proj in portfolio.projects:
        if not show_all and proj.is_complete:
            continue

        proj_node = TreeNode(
            type='project',
            id=proj.path,
            label=proj.name,
            data=proj,
            expanded=True,
            parent=root,
            project_ref=proj,
        )

        for epic_name in sorted(proj.epics):
            epic_node = TreeNode(
                type='epic',
                id=f"{proj.path}:{epic_name}",
                label=epic_name,
                data=None,  # Loaded on expand
                expanded=False,
                parent=proj_node,
                project_ref=proj,
            )
            proj_node.children.append(epic_node)

        if proj_node.children or show_all:
            root.children.append(proj_node)

    return root


def expand_epic(node: TreeNode, show_all: bool = False) -> None:
    """Populate epic children on first expansion (lazy load)."""
    if node.type != 'epic' or node.children:
        return

    proj = node.project_ref
    if not proj:
        return

    model = proj.load_detail()
    epic = model.epics.get(node.label)
    if not epic:
        return

    node.data = epic

    for feat in sorted(epic.features, key=lambda f: f.id):
        if not show_all and feat.is_done:
            continue

        feat_node = TreeNode(
            type='feature',
            id=feat.id,
            label=f"{feat.id} {feat.title}",
            data=feat,
            parent=node,
            project_ref=proj,
        )
        node.children.append(feat_node)


def expand_all(node: TreeNode, show_all: bool = False) -> None:
    """Recursively expand node and all descendants."""
    if node.type == 'epic' and not node.children:
        expand_epic(node, show_all)
    node.expanded = True
    for child in node.children:
        expand_all(child, show_all)


def collapse_all(node: TreeNode) -> None:
    """Recursively collapse node and all descendants."""
    node.expanded = False
    for child in node.children:
        collapse_all(child)


def flatten_tree(node: TreeNode, depth: int = 0, zoomed: TreeNode | None = None) -> list[tuple[int, TreeNode]]:
    """Flatten tree to (depth, node) pairs for rendering.
    If zoomed is set, only include that node and its descendants.
    """
    result = []

    # If zoomed, start from zoomed node as if it were root
    if zoomed and node.type == 'root':
        return flatten_tree(zoomed, 0, None)

    if node.type != 'root':
        result.append((depth, node))

    if node.type == 'root' or node.expanded:
        for child in node.children:
            child_depth = depth + 1 if node.type != 'root' else 0
            result.extend(flatten_tree(child, child_depth, None))

    return result


def find_parent_idx(flat: list[tuple[int, TreeNode]], cursor_idx: int) -> int:
    """Find index of parent node in flattened list."""
    if cursor_idx <= 0 or cursor_idx >= len(flat):
        return -1

    current_depth, _ = flat[cursor_idx]

    for i in range(cursor_idx - 1, -1, -1):
        depth, _ = flat[i]
        if depth < current_depth:
            return i

    return -1


def search_tree(node: TreeNode, query: str) -> list[TreeNode]:
    """Find all nodes matching query (case-insensitive)."""
    matches = []
    query_lower = query.lower()

    if node.type != 'root':
        if query_lower in node.label.lower():
            matches.append(node)
        elif node.type == 'feature' and node.data and node.data.description:
            if query_lower in node.data.description.lower():
                matches.append(node)

    for child in node.children:
        matches.extend(search_tree(child, query))

    return matches


def expand_path_to(node: TreeNode, show_all: bool = False) -> None:
    """Expand all ancestors to make node visible."""
    current = node.parent
    while current and current.type != 'root':
        if current.type == 'epic' and not current.children:
            expand_epic(current, show_all)
        current.expanded = True
        current = current.parent


def find_node_idx(flat: list[tuple[int, TreeNode]], target: TreeNode) -> int:
    """Find index of node in flattened list."""
    for i, (_, node) in enumerate(flat):
        if node is target:
            return i
    return -1


# ═══════════════════════════════════════════════════════════════════════════════
# VIEWS
# ═══════════════════════════════════════════════════════════════════════════════

def view_portfolio(portfolio: Portfolio, state: 'State', width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('PORTFOLIO', inner))
    lines.append('')

    pct = (portfolio.total_done / portfolio.total_features * 100) if portfolio.total_features else 0
    bar_width = min(30, inner - 50)
    lines.append(f"  {portfolio.total_projects} projects   {portfolio.total_features} features   "
                 f"{progress_bar(portfolio.total_done, portfolio.total_features, bar_width)}  "
                 f"{portfolio.total_done} done ({pct:.0f}%)")

    status = []
    if portfolio.active_projects:
        status.append(ansi(f"● {portfolio.active_projects} active", COLOR_ACTIVE))
    if portfolio.stalled_projects:
        status.append(ansi(f"○ {portfolio.stalled_projects} stalled", COLOR_STALLED))
    if portfolio.complete_projects:
        status.append(ansi(f"✓ {portfolio.complete_projects} complete", COLOR_HEALTHY))
    lines.append('  ' + '    '.join(status))

    lines.append('')
    lines.append(section_header(f'PROJECTS (sort: {state.sort_mode})', inner))
    lines.append('')

    filtered = portfolio.filtered(state.show_all, state.stalled_only)
    sorted_projects = portfolio.sorted_by(state.sort_mode)
    display = [p for p in sorted_projects if p in filtered]

    for i, proj in enumerate(display):
        cursor = ansi('▸', COLOR_PROJECT, bold=True) if i == state.project_index else ' '
        name = truncate(proj.name, 16).ljust(16)
        bar = progress_bar(proj.done, proj.total, 16)
        count = f"{proj.done}/{proj.total}".rjust(7)
        pct_str = f"{proj.percent:3.0f}%"

        if proj.is_complete:
            status_str = ansi('✓ complete', COLOR_HEALTHY)
        elif proj.is_stalled:
            status_str = ansi('○ stalled ', COLOR_STALLED)
        elif proj.active:
            status_str = ansi(f'● {proj.active} active', COLOR_ACTIVE)
        else:
            status_str = ansi(f'○ {proj.pending} pending', COLOR_MUTED)

        if proj.last_modified:
            mod = proj.last_modified.strftime('%b %d')
        else:
            mod = '   -  '
        today_mark = ansi('◆', COLOR_ACTIVE) if proj.worked_today else ' '

        lines.append(f" {cursor}{ansi(name, COLOR_PROJECT)}  {bar}  {count} {pct_str}  {status_str}  {today_mark} {mod}")

    if not display:
        lines.append(f"  {ansi('No projects match current filter', COLOR_MUTED)}")

    stalled = [p for p in portfolio.projects if p.is_stalled]
    if stalled and not state.stalled_only:
        lines.append('')
        lines.append(section_header('ATTENTION', inner))
        lines.append('')
        for proj in stalled[:3]:
            days = (datetime.now() - proj.last_modified).days if proj.last_modified else '?'
            lines.append(f"  {ansi('⚠', COLOR_STALLED)} {proj.name}: stalled {days} days, {proj.pending} pending")

    lines.append('')
    return lines


def view_project(model: Model, state: 'State', width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('PROGRESS', inner))
    lines.append('')

    pct = (model.done / model.total * 100) if model.total else 0
    bar_width = min(50, inner - 20)
    lines.append(f"  {progress_bar(model.done, model.total, bar_width)}  {model.done}/{model.total}  {pct:.1f}%")

    status_parts = []
    if model.done:
        status_parts.append(ansi(f"✓ {model.done} done", STATUS_COLOR['done']))
    if model.active:
        status_parts.append(ansi(f"◉ {model.active} active", STATUS_COLOR['in_progress']))
    if model.pending:
        status_parts.append(ansi(f"○ {model.pending} pending", STATUS_COLOR['pending']))
    abandoned = sum(1 for f in model.features.values() if f.status == 'abandoned')
    if abandoned:
        status_parts.append(ansi(f"✗ {abandoned} abandoned", STATUS_COLOR['abandoned']))
    superseded = sum(1 for f in model.features.values() if f.status == 'superseded')
    if superseded:
        status_parts.append(ansi(f"↷ {superseded} superseded", STATUS_COLOR['superseded']))
    lines.append('  ' + '   '.join(status_parts))

    lines.append('')
    lines.append(section_header('EPICS', inner))
    lines.append('')

    for i, (epic_name, epic) in enumerate(model.epics.items()):
        bar_w = 16
        bar = progress_bar(epic.done, epic.total, bar_w)
        pct_str = f"{epic.percent:3.0f}%" if epic.total else "  -"
        name = truncate(epic_name, 12).ljust(12)
        count = f"{epic.done}/{epic.total}".rjust(5)

        status_hint = ''
        if epic.active:
            status_hint += ansi(f"  ◉ {epic.active} active", STATUS_COLOR['in_progress'])
        if epic.pending:
            status_hint += ansi(f"  ○ {epic.pending} pending", STATUS_COLOR['pending'])

        cursor = ansi('▸', COLOR_EPIC, bold=True) if i == state.epic_index else ' '
        lines.append(f" {cursor}{ansi(name, COLOR_EPIC)}  {bar}  {count} {pct_str}{status_hint}")

    lines.append('')
    lines.append(section_header('RECENT', inner))
    lines.append('')

    sorted_dates = sorted(model.activity.keys(), reverse=True)[:5]
    max_count = max((len(model.activity[d]) for d in sorted_dates), default=1)

    for date in sorted_dates:
        feature_ids = model.activity[date]
        count = len(feature_ids)
        spark_width = min(14, int(count / max_count * 14)) if max_count else 0
        spark = ansi('█' * spark_width + '░' * (14 - spark_width), 34)

        try:
            dt = datetime.fromisoformat(date)
            date_str = dt.strftime('%b %d')
        except ValueError:
            date_str = date[-5:]

        ids_preview = ', '.join(feature_ids[:3])
        if len(feature_ids) > 3:
            ids_preview += f'... (+{len(feature_ids) - 3})'

        lines.append(f"  {date_str}  {spark}  {ansi(ids_preview, COLOR_MUTED)}")

    lines.append('')
    lines.append(section_header('NEXT UP', inner))
    lines.append('')

    upcoming = model.upcoming()[:3]
    for feat in upcoming:
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        name = truncate(feat.id, 18).ljust(18)
        title = truncate(feat.title, 35).ljust(35)

        unlocks = model.unlocks(feat.id)
        unlock_str = f"→ unlocks: {', '.join(unlocks[:2])}" if unlocks else ''

        lines.append(f"  {ansi(sym, color)} {ansi(name, color)}  {title}  {ansi(unlock_str, COLOR_DEP)}")

    if not upcoming:
        lines.append(f"  {ansi('All features complete!', COLOR_HEALTHY)}")

    lines.append('')
    return lines


def view_epic(model: Model, epic_name: str, state: 'State', width: int, height: int) -> list[str]:
    epic = model.epics.get(epic_name)
    if not epic:
        return [f"  Epic '{epic_name}' not found"]

    lines = []
    inner = width - 4

    lines.append('')
    bar_w = min(50, inner - 30)
    lines.append(f"  {progress_bar(epic.done, epic.total, bar_w)}  {epic.done}/{epic.total} completed  {epic.percent:.0f}%")

    lines.append('')
    lines.append(section_header('FEATURES', inner))
    lines.append('')

    sorted_features = sorted(epic.features, key=lambda f: f.id)
    for i, feat in enumerate(sorted_features):
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        fid = truncate(feat.id, 14).ljust(14)
        title = truncate(feat.title, 45)

        deps = ''
        if feat.depends_on:
            dep_short = [d.split('-')[-1] if '-' in d else d for d in feat.depends_on[:2]]
            deps = ansi(f"← {', '.join(dep_short)}", COLOR_DEP)

        cursor = ansi('▸', COLOR_EPIC, bold=True) if i == state.feature_index else ' '
        lines.append(f" {cursor}{ansi(sym, color)} {fid}  {title}  {deps}")

    lines.append('')
    return lines


def view_feature(model: Model, feature_id: str, width: int, height: int) -> list[str]:
    feat = model.features.get(feature_id)
    if not feat:
        return [f"  Feature '{feature_id}' not found"]

    lines = []
    inner = width - 4

    lines.append('')
    sym = STATUS_SYMBOL.get(feat.status, '?')
    color = STATUS_COLOR.get(feat.status, 0)
    lines.append(f"  {ansi(feat.title, bold=True)}")
    lines.append(f"  {ansi(f'{sym} {feat.status}', color)}")

    if feat.description:
        lines.append('')
        lines.append(section_header('DESCRIPTION', inner))
        lines.append('')
        words = feat.description.split()
        line = '  '
        for word in words:
            if len(line) + len(word) + 1 > inner:
                lines.append(line)
                line = '  '
            line += word + ' '
        if line.strip():
            lines.append(line)

    lines.append('')
    lines.append(section_header('METADATA', inner))
    lines.append('')

    if feat.epic:
        lines.append(f"  {'Epic':<12}  {ansi(feat.epic, COLOR_EPIC)}")
    if feat.priority is not None:
        prio_label = {0: 'critical', 1: 'high', 2: 'medium', 3: 'low'}.get(feat.priority, str(feat.priority))
        lines.append(f"  {'Priority':<12}  {feat.priority} ({prio_label})")
    if feat.created_at:
        lines.append(f"  {'Created':<12}  {feat.created_at}")
    if feat.spec_file:
        lines.append(f"  {'Spec':<12}  {ansi(feat.spec_file, COLOR_MUTED)}")

    lines.append('')
    lines.append(section_header('DEPENDENCIES', inner))
    lines.append('')

    if feat.depends_on:
        deps_status = []
        for dep_id in feat.depends_on:
            dep = model.features.get(dep_id)
            if dep:
                s = STATUS_SYMBOL.get(dep.status, '?')
                deps_status.append(f"{dep_id} {ansi(s, STATUS_COLOR.get(dep.status, 0))}")
            else:
                deps_status.append(f"{dep_id} ?")
        lines.append(f"  {'Blocked by:':<12}  {', '.join(deps_status)}")
    else:
        lines.append(f"  {'Blocked by:':<12}  (none)")

    unlocks = model.unlocks(feature_id)
    lines.append(f"  {'Unlocks:':<12}  {', '.join(unlocks) if unlocks else '(none)'}")

    if feat.steps:
        lines.append('')
        lines.append(section_header('STEPS', inner))
        lines.append('')
        for i, step in enumerate(feat.steps, 1):
            lines.append(f"  {i}. {truncate(step, inner - 6)}")

    lines.append('')
    return lines


def view_feature_editable(feat: 'Feature', edit: EditState, width: int) -> list[str]:
    """Render feature view in edit mode with field cursor."""
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(f"  {ansi(feat.title or feat.id, bold=True)}")
    lines.append('')
    lines.append(section_header('EDIT FIELDS', inner))
    lines.append('')

    for i, field in enumerate(EDITABLE_FIELDS):
        is_current = (i == edit.field_idx and edit.mode == 'edit')

        # Get value: pending_changes > current editing > feature attribute
        if is_current:
            value = edit.editing_value
        elif field in edit.pending_changes:
            value = edit.pending_changes[field]
        else:
            value = getattr(feat, field, '') or ''

        if field == 'status':
            # Radio buttons
            options = []
            for opt in STATUS_OPTIONS:
                marker = '◉' if value == opt else '○'
                color = STATUS_COLOR.get(opt, 0)
                styled = ansi(f'{marker} {opt}', color)
                options.append(styled)
            display = '  '.join(options)
        elif field == 'depends_on':
            if isinstance(value, list):
                display = f"[{', '.join(value)}]"
            else:
                display = f"[{value}]"
        else:
            display = f"[{value}]"

        prefix = '▸ ' if is_current else '  '
        label = f"{field}:".ljust(14)
        lines.append(f"{prefix}{ansi(label, COLOR_MUTED)}{display}")

    lines.append('')
    return lines


def view_tree(state: 'State', width: int, height: int) -> list[str]:
    """Render tree view."""
    lines = []
    inner = width - 4

    if not state.tree or not state.tree.root:
        return ['  No tree data']

    flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)

    if not flat:
        lines.append('')
        filter_msg = '(all items filtered)' if not state.tree.show_all else '(no projects)'
        lines.append(f"  {ansi(f'Empty tree {filter_msg}', COLOR_MUTED)}")
        lines.append(f"  {ansi('Press [a] to show all', COLOR_MUTED)}")
        return lines

    # Search mode header
    if state.tree.search_mode:
        search_line = f"  /{state.tree.search_query}█"
        if state.tree.search_matches:
            match_info = f" ({state.tree.search_index + 1}/{len(state.tree.search_matches)})"
            search_line += ansi(match_info, COLOR_MUTED)
        lines.append(search_line)
        lines.append('')

    visible_height = max(1, height - 6)
    if state.tree.search_mode:
        visible_height -= 2
    cursor_idx = state.tree.cursor_idx
    scroll = state.tree.scroll_offset

    # Adjust scroll to keep cursor visible
    if cursor_idx < scroll:
        scroll = cursor_idx
    elif cursor_idx >= scroll + visible_height:
        scroll = cursor_idx - visible_height + 1
    state.tree.scroll_offset = max(0, scroll)

    lines.append('')

    for i, (depth, node) in enumerate(flat[scroll:scroll + visible_height]):
        actual_idx = i + scroll
        is_cursor = (actual_idx == cursor_idx)
        is_match = node in state.tree.search_matches
        line = render_tree_node(depth, node, is_cursor, inner, is_match)
        lines.append(line)

    # Stats footer
    lines.append('')
    proj_count = sum(1 for _, n in flat if n.type == 'project')
    epic_count = sum(1 for _, n in flat if n.type == 'epic')
    feat_count = sum(1 for _, n in flat if n.type == 'feature')
    stats = f'{proj_count} projects, {epic_count} epics, {feat_count} features'
    if state.tree.search_matches and not state.tree.search_mode:
        stats += f' | {len(state.tree.search_matches)} matches'
    lines.append(f"  {ansi(stats, COLOR_MUTED)}")

    return lines


def render_tree_node(depth: int, node: TreeNode, is_cursor: bool, width: int, is_match: bool = False) -> str:
    """Render single tree node line."""
    indent = '  ' * depth

    # Expand/collapse indicator
    if node.has_children:
        arrow = '▼ ' if node.expanded else '► '
    else:
        arrow = '  '

    # Status symbol for features
    if node.type == 'feature':
        feat = node.data
        sym = STATUS_SYMBOL.get(feat.status, '?')
        color = STATUS_COLOR.get(feat.status, 0)
        prefix = ansi(sym, color) + ' '
    else:
        prefix = ''

    # Label with appropriate color
    if node.type == 'project':
        label = ansi(node.label, COLOR_PROJECT, bold=is_cursor)
    elif node.type == 'epic':
        label = ansi(node.label, COLOR_EPIC, bold=is_cursor)
    else:
        label = node.label

    # Progress bar for project/epic
    progress = ''
    if node.type == 'project':
        proj = node.data
        bar = progress_bar(proj.done, proj.total, 12)
        pct = f"{proj.percent:.0f}%"
        progress = f"  {proj.done}/{proj.total} {bar} {pct}"
    elif node.type == 'epic' and node.data and node.expanded:
        epic = node.data
        bar = progress_bar(epic.done, epic.total, 12)
        pct = f"{epic.percent:.0f}%"
        progress = f"  {epic.done}/{epic.total} {bar} {pct}"

    # Dependencies for features
    deps = ''
    if node.type == 'feature' and node.data.depends_on:
        dep_ids = ', '.join(node.data.depends_on[:2])
        if len(node.data.depends_on) > 2:
            dep_ids += '...'
        deps = ansi(f" ← {dep_ids}", COLOR_DEP)

    # Match indicator
    match_marker = ansi('●', 220) + ' ' if is_match else ''

    # Cursor indicator
    cursor = ansi('▸', COLOR_PROJECT, bold=True) if is_cursor else ' '

    return f"{cursor}{indent}{arrow}{match_marker}{prefix}{label}{progress}{deps}"


def view_help(width: int, height: int) -> list[str]:
    lines = []
    inner = width - 4

    lines.append('')
    lines.append(section_header('NAVIGATION', inner))
    lines.append('')
    lines.append(f"  {ansi('j', bold=True)} / {ansi('↓', bold=True)}      Move selection down")
    lines.append(f"  {ansi('k', bold=True)} / {ansi('↑', bold=True)}      Move selection up")
    lines.append(f"  {ansi('Enter', bold=True)}      Drill down into selected item")
    lines.append(f"  {ansi('Esc', bold=True)} / {ansi('b', bold=True)}    Go back (quit at top level)")
    lines.append(f"  {ansi('h', bold=True)} / {ansi('?', bold=True)}      Show this help")
    lines.append(f"  {ansi('q', bold=True)}          Quit immediately")
    lines.append('')
    lines.append(section_header('PORTFOLIO CONTROLS', inner))
    lines.append('')
    lines.append(f"  {ansi('s', bold=True)}          Cycle sort mode (pending/modified/total/completion)")
    lines.append(f"  {ansi('a', bold=True)}          Toggle show all projects (including complete)")
    lines.append(f"  {ansi('z', bold=True)}          Show only stalled projects")
    lines.append(f"  {ansi('t', bold=True)}          Switch to tree view")
    lines.append('')
    lines.append(section_header('TREE VIEW', inner))
    lines.append('')
    lines.append(f"  {ansi('h', bold=True)} / {ansi('←', bold=True)}      Collapse node or move to parent")
    lines.append(f"  {ansi('l', bold=True)} / {ansi('→', bold=True)}      Expand node or drill into feature")
    lines.append(f"  {ansi('o', bold=True)}          Toggle expand/collapse")
    lines.append(f"  {ansi('O', bold=True)}          Expand all under cursor")
    lines.append(f"  {ansi('M', bold=True)}          Collapse all")
    lines.append(f"  {ansi('t', bold=True)}          Switch back to table view")
    lines.append('')
    lines.append(section_header('STATUS SYMBOLS', inner))
    lines.append('')
    lines.append(f"  {ansi('✓', STATUS_COLOR['done'])}  done        {ansi('◉', STATUS_COLOR['in_progress'])}  in progress")
    lines.append(f"  {ansi('○', STATUS_COLOR['pending'])}  pending     {ansi('✗', STATUS_COLOR['abandoned'])}  abandoned")
    lines.append(f"  {ansi('↷', STATUS_COLOR['superseded'])}  superseded  {ansi('◆', COLOR_ACTIVE)}  worked today")
    lines.append('')
    lines.append(section_header('USAGE', inner))
    lines.append('')
    lines.append(f"  {ansi('pv', bold=True)}                   Scan ~/Code, portfolio view")
    lines.append(f"  {ansi('pv /path', bold=True)}             Scan specific directory")
    lines.append(f"  {ansi('pv features.json', bold=True)}     Project view for specific file")
    lines.append(f"  {ansi('fv', bold=True)}                   Project view for ./features.json")
    lines.append('')

    return lines


# ═══════════════════════════════════════════════════════════════════════════════
# STATE & INPUT
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class State:
    view: str = 'portfolio'

    # Portfolio level
    portfolio: Portfolio | None = None
    project_index: int = 0
    sort_mode: str = 'open'
    show_all: bool = False
    stalled_only: bool = False

    # Project level
    current_project: ProjectSummary | None = None
    epic_index: int = 0

    # Epic level
    current_epic: str | None = None
    feature_index: int = 0

    # Feature level
    current_feature: str | None = None

    # Previous view for help overlay
    prev_view: str | None = None

    # Tree view
    tree: TreeState | None = None

    # Edit mode
    edit: EditState | None = None
    dirty: bool = False


def handle_input(key: str, state: State) -> State | None:
    # Handle quit confirmation when dirty
    if state.edit and state.edit.confirm_action == 'quit':
        if key == 's':
            apply_pending_changes(state)
            save_features(state.current_project)
            return None
        elif key == 'd':
            return None
        elif key == 'c':
            state.edit.confirm_action = None
        return state

    # Help toggle (h conflicts with tree navigation, so only use ? in tree view)
    if key == '?' or (key == 'h' and state.view != 'tree'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
        else:
            state.prev_view = state.view
            state.view = 'help'
        return state

    # Quit
    if key in ('q', '\x03'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
            return state
        # Prompt for unsaved changes
        if state.dirty:
            if not state.edit:
                state.edit = EditState()
            state.edit.confirm_action = 'quit'
            return state
        return None

    # Back navigation (Esc/b/Backspace) - go back one level, quit at top
    if key in ('\x1b', 'b', '\x7f'):
        if state.view == 'help':
            state.view = state.prev_view or 'portfolio'
            state.prev_view = None
        elif state.view == 'feature':
            # In edit mode, Esc returns to navigate mode (handled by handle_feature_input)
            if state.edit and state.edit.mode == 'edit':
                return handle_feature_input(key, state)
            # In navigate mode, go back
            if state.tree:
                state.view = 'tree'
            else:
                state.view = 'epic'
            state.current_feature = None
            state.edit = None
        elif state.view == 'epic':
            state.view = 'project'
            state.current_epic = None
            state.feature_index = 0
        elif state.view == 'project':
            if state.portfolio:
                state.view = 'portfolio'
                state.current_project = None
                state.epic_index = 0
            else:
                # Direct project mode (fv), no portfolio to go back to → quit
                return None
        elif state.view == 'tree':
            state.view = 'portfolio'
            state.tree = None
        elif state.view == 'portfolio':
            # At top level, Esc quits (natural "escape out" pattern)
            return None
        return state

    # View-specific input handling
    if state.view == 'portfolio':
        return handle_portfolio_input(key, state)
    elif state.view == 'project':
        return handle_project_input(key, state)
    elif state.view == 'epic':
        return handle_epic_input(key, state)
    elif state.view == 'feature':
        return handle_feature_input(key, state)
    elif state.view == 'tree':
        return handle_tree_input(key, state)

    return state


def handle_portfolio_input(key: str, state: State) -> State:
    portfolio = state.portfolio
    if not portfolio:
        return state

    filtered = portfolio.filtered(state.show_all, state.stalled_only)
    sorted_projects = portfolio.sorted_by(state.sort_mode)
    display = [p for p in sorted_projects if p in filtered]

    if key in ('j', 'down'):
        state.project_index = min(state.project_index + 1, len(display) - 1)
    elif key in ('k', 'up'):
        state.project_index = max(state.project_index - 1, 0)
    elif key == 's':
        idx = SORT_MODES.index(state.sort_mode)
        state.sort_mode = SORT_MODES[(idx + 1) % len(SORT_MODES)]
        state.project_index = 0
    elif key == 'a':
        state.show_all = not state.show_all
        state.stalled_only = False
        state.project_index = 0
    elif key == 'z':
        state.stalled_only = not state.stalled_only
        state.show_all = False
        state.project_index = 0
    elif key in ('\r', '\n'):
        if display and 0 <= state.project_index < len(display):
            state.current_project = display[state.project_index]
            state.current_project.load_detail()
            state.view = 'project'
            state.epic_index = 0
    elif key == 't':
        state.tree = TreeState(
            root=build_tree(state.portfolio, state.show_all),
            show_all=state.show_all,
        )
        state.view = 'tree'

    return state


def handle_project_input(key: str, state: State) -> State:
    if not state.current_project or not state.current_project._detail:
        return state

    model = state.current_project._detail
    epic_names = list(model.epics.keys())

    if key in ('j', 'down'):
        state.epic_index = min(state.epic_index + 1, len(epic_names) - 1)
    elif key in ('k', 'up'):
        state.epic_index = max(state.epic_index - 1, 0)
    elif key in ('\r', '\n'):
        if epic_names and 0 <= state.epic_index < len(epic_names):
            state.current_epic = epic_names[state.epic_index]
            state.view = 'epic'
            state.feature_index = 0

    return state


def handle_epic_input(key: str, state: State) -> State:
    if not state.current_project or not state.current_project._detail or not state.current_epic:
        return state

    model = state.current_project._detail
    epic = model.epics.get(state.current_epic)
    if not epic:
        return state

    sorted_features = sorted(epic.features, key=lambda f: f.id)

    if key in ('j', 'down'):
        state.feature_index = min(state.feature_index + 1, len(sorted_features) - 1)
    elif key in ('k', 'up'):
        state.feature_index = max(state.feature_index - 1, 0)
    elif key in ('\r', '\n'):
        if sorted_features and 0 <= state.feature_index < len(sorted_features):
            state.current_feature = sorted_features[state.feature_index].id
            state.view = 'feature'
            state.edit = None  # Reset edit state when entering feature
    elif key == 'n':
        feat = create_feature(model, state.current_epic)
        state.current_feature = feat.id
        state.view = 'feature'
        state.edit = EditState(mode='edit')
        load_field_value(state)
        state.dirty = True

    return state


def next_feature_id(model: 'Model', epic: str) -> str:
    """Generate next ID for epic (e.g., auth-005)."""
    pattern = re.compile(rf'^{re.escape(epic)}-(\d+)$')

    max_num = 0
    for fid in model.features.keys():
        match = pattern.match(fid)
        if match:
            max_num = max(max_num, int(match.group(1)))

    return f"{epic}-{max_num + 1:03d}"


def create_feature(model: 'Model', epic_name: str) -> 'Feature':
    """Create new feature in epic."""
    new_id = next_feature_id(model, epic_name)
    today = datetime.now().strftime('%Y-%m-%d')

    feat = Feature(
        id=new_id,
        status='pending',
        title='',
        epic=epic_name,
        created_at=today,
    )

    model.features[new_id] = feat

    if epic_name not in model.epics:
        model.epics[epic_name] = Epic(name=epic_name)
    model.epics[epic_name].features.append(feat)

    return feat


def handle_feature_input(key: str, state: State) -> State:
    """Handle input in feature view (navigate + edit modes)."""
    if not state.current_project or not state.current_project._detail or not state.current_feature:
        return state

    if not state.edit:
        state.edit = EditState()

    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return state

    # Handle confirmation dialogs first
    if state.edit.confirm_action == 'delete':
        if key == 'y':
            model = state.current_project._detail
            feat_id = state.current_feature
            feat_obj = model.features.get(feat_id)
            if feat_obj:
                del model.features[feat_id]
                if feat_obj.epic and feat_obj.epic in model.epics:
                    model.epics[feat_obj.epic].features = [
                        f for f in model.epics[feat_obj.epic].features if f.id != feat_id
                    ]
            state.dirty = True
            state.edit.confirm_action = None
            state.current_feature = None
            state.view = 'epic'
        elif key == 'n':
            state.edit.confirm_action = None
        return state

    # Navigate mode
    if state.edit.mode == 'navigate':
        if key == 'e':
            state.edit.mode = 'edit'
            state.edit.field_idx = 0
            load_field_value(state)
        elif key == 'D':
            state.edit.confirm_action = 'delete'
        elif key == 'w' and state.dirty:
            apply_pending_changes(state)
            if save_features(state.current_project):
                state.dirty = False
                state.edit.pending_changes.clear()
        return state

    # Edit mode
    if key == '\x1b':  # Esc - commit current field and exit edit mode
        commit_field_edit(state)
        state.edit.mode = 'navigate'
        state.edit.editing_value = ''
        return state

    if key == '\t':  # Tab - commit and advance
        commit_field_edit(state)
        state.edit.field_idx = (state.edit.field_idx + 1) % len(EDITABLE_FIELDS)
        load_field_value(state)
        return state

    field = EDITABLE_FIELDS[state.edit.field_idx]

    if field == 'status':
        if key in ('j', 'down'):
            current = state.edit.editing_value
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx + 1) % len(STATUS_OPTIONS)]
            state.dirty = True
        elif key in ('k', 'up'):
            current = state.edit.editing_value
            idx = STATUS_OPTIONS.index(current) if current in STATUS_OPTIONS else 0
            state.edit.editing_value = STATUS_OPTIONS[(idx - 1) % len(STATUS_OPTIONS)]
            state.dirty = True
    else:
        # Text field editing
        if key == '\x7f':  # Backspace
            state.edit.editing_value = state.edit.editing_value[:-1]
            state.dirty = True
        elif len(key) == 1 and key.isprintable():
            state.edit.editing_value += key
            state.dirty = True

    return state


def load_field_value(state: State) -> None:
    """Load current field value into editing_value."""
    if not state.edit or not state.current_project or not state.current_feature:
        return

    field = EDITABLE_FIELDS[state.edit.field_idx]
    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return

    if field in state.edit.pending_changes:
        value = state.edit.pending_changes[field]
    else:
        value = getattr(feat, field, '') or ''

    if field == 'depends_on' and isinstance(value, list):
        value = ', '.join(value)

    state.edit.editing_value = str(value) if value else ''


def commit_field_edit(state: State) -> None:
    """Store current editing_value in pending_changes."""
    if not state.edit:
        return

    field = EDITABLE_FIELDS[state.edit.field_idx]
    value = state.edit.editing_value

    if field == 'depends_on':
        value = [x.strip() for x in value.split(',') if x.strip()]
    elif field == 'priority':
        try:
            value = int(value) if value else None
        except ValueError:
            value = None

    state.edit.pending_changes[field] = value


def apply_pending_changes(state: State) -> None:
    """Apply pending edits to Feature object."""
    if not state.edit:
        return

    feat = state.current_project._detail.features.get(state.current_feature)
    if not feat:
        return

    # Only commit current field if we're still in edit mode
    if state.edit.mode == 'edit':
        commit_field_edit(state)

    # Apply all pending changes to feature
    for field, value in state.edit.pending_changes.items():
        setattr(feat, field, value)

    state.edit.pending_changes.clear()


def save_features(project: 'ProjectSummary') -> bool:
    """Save features.json. Returns True on success."""
    features_path = os.path.join(project.path, 'features.json')
    model = project._detail
    if not model:
        return False

    data = []
    for feat in model.features.values():
        item = {'id': feat.id, 'status': feat.status}
        for attr in ['title', 'description', 'epic', 'depends_on', 'priority',
                     'created_at', 'spec_file', 'steps', 'discovered_from', 'notes']:
            val = getattr(feat, attr, None)
            if val:
                item[attr] = val
        data.append(item)

    data.sort(key=lambda x: x['id'])

    with open(features_path, 'w') as f:
        json.dump(data, f, indent=2)
        f.write('\n')

    return True


def handle_tree_input(key: str, state: State) -> State:
    """Handle input in tree view."""
    if not state.tree:
        return state

    # Handle search mode input
    if state.tree.search_mode:
        return handle_tree_search_input(key, state)

    flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)

    # Handle empty tree
    if not flat:
        if key == 't':
            state.view = 'portfolio'
        elif key == 'a':
            state.tree.show_all = not state.tree.show_all
            state.tree.root = build_tree(state.portfolio, state.tree.show_all)
            state.tree.cursor_idx = 0
        elif key == '/':
            state.tree.search_mode = True
            state.tree.search_query = ''
        return state

    # Clamp cursor to valid range
    cursor_idx = min(state.tree.cursor_idx, len(flat) - 1)
    cursor_idx = max(0, cursor_idx)
    state.tree.cursor_idx = cursor_idx

    if key in ('j', 'down'):
        if cursor_idx < len(flat) - 1:
            state.tree.cursor_idx = cursor_idx + 1

    elif key in ('k', 'up'):
        if cursor_idx > 0:
            state.tree.cursor_idx = cursor_idx - 1

    elif key in ('l', 'right', '\r', '\n'):
        _, node = flat[cursor_idx]
        if node.type == 'epic' and not node.expanded:
            expand_epic(node, state.tree.show_all)
            node.expanded = True
        elif node.has_children and not node.expanded:
            node.expanded = True
        elif node.type == 'feature':
            proj = node.project_ref
            if proj:
                proj.load_detail()
                state.current_project = proj
                state.current_epic = node.parent.label if node.parent else None
                state.current_feature = node.data.id
                state.view = 'feature'

    elif key in ('h', 'left'):
        _, node = flat[cursor_idx]
        if node.expanded:
            node.expanded = False
        else:
            parent_idx = find_parent_idx(flat, cursor_idx)
            if parent_idx >= 0:
                state.tree.cursor_idx = parent_idx

    elif key == 'o':
        _, node = flat[cursor_idx]
        if node.type == 'epic' and not node.expanded:
            expand_epic(node, state.tree.show_all)
        if node.has_children:
            node.expanded = not node.expanded

    elif key == 'O':
        _, node = flat[cursor_idx]
        expand_all(node, state.tree.show_all)

    elif key == 'M':
        collapse_all(state.tree.root)
        state.tree.cursor_idx = 0
        state.tree.search_matches = []

    elif key == 't':
        state.view = 'portfolio'

    elif key == 'a':
        state.tree.show_all = not state.tree.show_all
        state.tree.root = build_tree(state.portfolio, state.tree.show_all)
        state.tree.cursor_idx = 0
        state.tree.search_matches = []

    elif key == '/':
        state.tree.search_mode = True
        state.tree.search_query = ''
        state.tree.search_matches = []
        state.tree.search_index = 0

    elif key == 'n' and state.tree.search_matches:
        # Next match
        state.tree.search_index = (state.tree.search_index + 1) % len(state.tree.search_matches)
        target = state.tree.search_matches[state.tree.search_index]
        expand_path_to(target, state.tree.show_all)
        flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
        idx = find_node_idx(flat, target)
        if idx >= 0:
            state.tree.cursor_idx = idx

    elif key == 'N' and state.tree.search_matches:
        # Previous match
        state.tree.search_index = (state.tree.search_index - 1) % len(state.tree.search_matches)
        target = state.tree.search_matches[state.tree.search_index]
        expand_path_to(target, state.tree.show_all)
        flat = flatten_tree(state.tree.root, zoomed=state.tree.zoomed_node)
        idx = find_node_idx(flat, target)
        if idx >= 0:
            state.tree.cursor_idx = idx

    elif key == 'z':
        # Toggle zoom
        _, node = flat[cursor_idx]
        if state.tree.zoomed_node == node:
            state.tree.zoomed_node = None  # Unzoom
        else:
            state.tree.zoomed_node = node  # Zoom to cursor
        state.tree.cursor_idx = 0

    return state


def handle_tree_search_input(key: str, state: State) -> State:
    """Handle input during search mode."""
    ts = state.tree

    if key == '\x1b':  # Escape - cancel search
        ts.search_mode = False
        ts.search_query = ''
        ts.search_matches = []
    elif key in ('\r', '\n'):  # Enter - confirm search, jump to first match
        ts.search_mode = False
        if ts.search_matches:
            target = ts.search_matches[ts.search_index]
            expand_path_to(target, ts.show_all)
            flat = flatten_tree(ts.root, zoomed=ts.zoomed_node)
            idx = find_node_idx(flat, target)
            if idx >= 0:
                ts.cursor_idx = idx
    elif key == '\x7f':  # Backspace
        ts.search_query = ts.search_query[:-1]
        if ts.search_query:
            ts.search_matches = search_tree(ts.root, ts.search_query)
        else:
            ts.search_matches = []
        ts.search_index = 0
    elif len(key) == 1 and key.isprintable():
        ts.search_query += key
        ts.search_matches = search_tree(ts.root, ts.search_query)
        ts.search_index = 0
        # Auto-expand to first match
        if ts.search_matches:
            expand_path_to(ts.search_matches[0], ts.show_all)

    return state


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

def render(state: State, width: int, height: int) -> str:
    if state.view == 'help':
        title = 'help'
        footer = '[Esc]back'
        lines = view_help(width, height)
    elif state.view == 'tree':
        title = 'tree'
        hints = []
        if state.tree and state.tree.show_all:
            hints.append('[all]')
        if state.tree and state.tree.zoomed_node:
            hints.append('[zoomed]')
        hint_str = ' ' + ' '.join(hints) if hints else ''
        if state.tree and state.tree.search_mode:
            footer = '[Enter]confirm [Esc]cancel'
        elif state.tree and state.tree.search_matches:
            footer = f'[n/N]next/prev [/]search [z]oom [t]table [q]uit{hint_str}'
        else:
            footer = f'[h/l]expand [o]toggle [/]search [z]oom [t]table [a]ll [q]uit{hint_str}'
        lines = view_tree(state, width, height)
    elif state.view == 'portfolio':
        title = 'pv'
        filter_hint = ''
        if state.show_all:
            filter_hint = ' [all]'
        elif state.stalled_only:
            filter_hint = ' [stalled]'
        footer = f'[s]ort [a]ll [z]stalled [t]ree [h]elp [q]uit{filter_hint}'
        lines = view_portfolio(state.portfolio, state, width, height)
    elif state.view == 'project':
        proj_name = state.current_project.name if state.current_project else 'project'
        title = proj_name
        footer = '[Esc]back [h]elp [q]uit'
        model = state.current_project._detail if state.current_project else None
        if model:
            lines = view_project(model, state, width, height)
        else:
            lines = ['  No project loaded']
    elif state.view == 'epic':
        title = f'epic: {state.current_epic}'
        footer = '[n]ew [Esc]back [h]elp [q]uit'
        model = state.current_project._detail if state.current_project else None
        if model and state.current_epic:
            lines = view_epic(model, state.current_epic, state, width, height)
        else:
            lines = ['  No epic selected']
    elif state.view == 'feature':
        title = state.current_feature or 'feature'
        model = state.current_project._detail if state.current_project else None

        # Build footer based on edit state
        if state.edit and state.edit.confirm_action == 'delete':
            footer = f"Delete {state.current_feature}? [y]es [n]o"
        elif state.edit and state.edit.confirm_action == 'quit':
            footer = "Unsaved changes. [s]ave [d]iscard [c]ancel"
        elif state.edit and state.edit.mode == 'edit':
            footer = "[Tab]next [j/k]status [Esc]exit"
        else:
            dirty_hint = " [w]rite" if state.dirty else ""
            footer = f"[e]dit [D]elete{dirty_hint} [Esc]back [q]uit"

        if state.dirty:
            footer = "[*] " + footer

        if model and state.current_feature:
            feat = model.features.get(state.current_feature)
            if feat and state.edit and state.edit.mode == 'edit':
                lines = view_feature_editable(feat, state.edit, width)
            else:
                lines = view_feature(model, state.current_feature, width, height)
        else:
            lines = ['  No feature selected']
    else:
        lines = ['  Unknown view']
        title = ''
        footer = ''

    framed = frame(lines, width, title, footer)
    return '\n'.join(framed)


def init_portfolio_state(root: str) -> State:
    portfolio = scan_projects(root)
    return State(view='portfolio', portfolio=portfolio)


def init_project_state(features_path: str) -> State:
    model = Model.load(features_path)
    proj = ProjectSummary.from_path(features_path)
    if proj:
        proj._detail = model
    else:
        proj = ProjectSummary(path=str(Path(features_path).parent), name=Path(features_path).parent.name)
        proj._detail = model
    return State(
        view='project',
        portfolio=None,
        current_project=proj,
    )


def detect_entry_point() -> State:
    prog_name = os.path.basename(sys.argv[0])
    is_fv_mode = prog_name in ('fv', 'fv.py')

    if len(sys.argv) < 2:
        if is_fv_mode:
            if os.path.exists('features.json'):
                return init_project_state('features.json')
            else:
                print("Error: features.json not found")
                print("Run from a directory containing features.json, or specify path.")
                sys.exit(1)
        else:
            return init_portfolio_state('~/Code')

    arg = sys.argv[1]

    if arg in ('-h', '--help'):
        print(__doc__)
        sys.exit(0)

    if arg.endswith('.json'):
        if not os.path.exists(arg):
            print(f"Error: {arg} not found")
            sys.exit(1)
        return init_project_state(arg)

    if os.path.isdir(arg):
        return init_portfolio_state(arg)

    print(f"Error: {arg} not found")
    sys.exit(1)


def main():
    try:
        state = detect_entry_point()
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}")
        sys.exit(1)
    except KeyError as e:
        print(f"Error: missing required field {e}")
        sys.exit(1)

    size = get_terminal_size()

    # Non-interactive mode
    if not sys.stdin.isatty():
        output = render(state, size.columns, size.lines)
        print(output)
        return

    # Clear screen and hide cursor
    print('\033[2J\033[H\033[?25l', end='')

    try:
        while True:
            size = get_terminal_size()
            output = render(state, size.columns, size.lines)
            print(f'\033[H{output}\033[J', end='', flush=True)

            key = getch()
            state = handle_input(key, state)
            if state is None:
                break
    finally:
        print('\033[?25h\033[2J\033[H', end='')


if __name__ == '__main__':
    main()
