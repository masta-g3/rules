<Codebase Structure>
- Check STRUCTURE.md to understand project organization
- Always verify current directory before creating files or terminal operations
- Place functions in appropriate utils/ scripts by purpose (data_utils.py, format_utils.py, etc.)
- Keep STRUCTURE.md updated with new files or content
</Codebase Structure>

<Coding Style>
- Prioritize minimalism: clean, readable, lightweight, modular code; avoid corporate bloat at all costs
- Never solve problems with hacks or hacky solutions; if an approach is not working, brainstorm alternatives with the user instead
- Don't introduce new patterns/technologies unless strictly needed
- Study existing functions to maintain consistent patterns and style
- Avoid thin wrappers and ad-hoc patches
- Make minimal, non-disruptive changes that follow existing structure
- Check for existing similar code to avoid duplication
- Keep function names direct and simple (no 'enhanced', 'new' prefixes)
- Avoid unecessary changelog style comments (or useless ones), such as 'new feature' indicators
- Avoid try-except except for minor processing failures; we don't want processes to fail silently
- Avoid adding fallback mechanism or default values unless the user explicitly asks
- Centralize imports at script top (for languages like python, where this is best practice)
</Coding Style>


<Step-by-Step Instructions (PLANNING.md)>
For complex requests:
1. Create a new PLANNING.md document (use PLANNING2.md, etc. if already taken)
2. Brainstorm solution approach:
   - Debugging: identify likely problem sources, validate assumptions
   - New features: inspect existing code patterns, avoid duplication
   - Consider alternatives that align with current style (modular, lightweight, clean, avoid corporate bloat)
3. Write out all steps needed [ ]
4. Mark completed steps [x] as you progress
5. Finally, verify if the plan actually corresponds to what was implemented, if there are divergences, update the document
</Step-by-Step Instructions (PLANNING.md)>

<Session Progress Tracking (PROGRESS.md)>
When working over long plans with PLANNING.md and a break is requested, create or update PROGRESS.md with a summary of the main objective and what was tackled this session. Think of this as a complimentary document to PLANNING.md.
- Include the main objective of the plan and what was tackled this session.
- Provide a brief overview of the discussion context and key decisions.
- Document exactly what was implemented and achieved in this session.
- Note important patterns or conventions to remember when resuming work.
- Call out challenges, risks, and likely pitfalls for the next engineer; add practical tips.
- Write with handoff in mind: enough context for another engineer to continue efficiently.
- Finally, also update PLANNING.md when a pause/break is requested, reflecting any changes in design and marking complete items as [x].
</Session Progress Tracking (PROGRESS.md)>

<Minimalist Design Philosophy>
We are working at a lean startup, maintained by 10x engineers, not a large corporation. Code accordingly:
- Less is more, elegance is clarity
- Avoid useless boilerplate code, be minimal and efficient
- Make components modular and reusable
- Follow existing styles and patterns
- Leave codebase simpler and more organized
- Skip redundant validations unless failure has real consequences
- Let errors surface naturally; avoid blanket try/except (especially "pass") that hides bugs
- No backward compatibility or defaults unless requested
- Comment only non-obvious logic
</Minimalist Design Philosophy>

<Reviewing and Logging Changes>
- Test functions without external effects when possible
- If testing impossible, validate code correctness
- Update STRUCTURE.md to reflect new/deleted files, or when important new functionality and changes to the codebase
</Reviewing and Logging Changes>

<Generating Documentation>
User will ask you to generate many .md files thougohut the process (PLANNING.md, STRUCTURE.md, etc). Adopt the following style:
- Multi-layered: overview → architecture → implementation details
- Lead with visual diagrams (prefer Mermaid) for flows and relationships
- Document "why" behind decisions - trade-offs, constraints, strategic context
- Include real metrics, usage patterns, concrete examples
- Essential sections: Overview, Architecture, Component Breakdown, Data Flow, Integration Points, Performance
- Focus on information not derivable from code
- Keep examples realistic and working
- Write for maintainers 6 months later
- Place docs close to code, maintain consistent terminology
- Document major features, complex algorithms, integration points, performance-critical paths
</Generating Documentation>

<Testing>
- Consider Test Driven Development as a possible philosophy for robust software development.
- Whenever possible create ephemereal tests to validate that your features, functions and implementations work as you expect. Remove these temporary tests once you finish working with them.
- Whenever you introduce new core or important features, add related tests in tests/ directory. Avoid over-testing; we want to mantain a lean set of unit tests that provide most code coverage with the least amount of code.
</Testing>
